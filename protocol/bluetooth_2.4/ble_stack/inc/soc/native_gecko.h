#ifndef NATIVE_GECKO_H
#define NATIVE_GECKO_H

/*****************************************************************************
 *
 *  Native BGAPI
 *
 *  Autogenerated file, do not edit
 *
 ****************************************************************************/

#ifdef __cplusplus
extern "C" {
#endif

#include <string.h>
#include "bg_types.h"
#include "gecko_configuration.h"

/* Compatibility */
#ifndef PACKSTRUCT
/*Default packed configuration*/
#ifdef __GNUC__
#ifdef _WIN32
#define PACKSTRUCT( decl ) decl __attribute__((__packed__,gcc_struct))
#else
#define PACKSTRUCT( decl ) decl __attribute__((__packed__))
#endif
#define ALIGNED __attribute__((aligned(0x4)))
#elif __IAR_SYSTEMS_ICC__

#define PACKSTRUCT( decl ) __packed decl

#define ALIGNED
#elif _MSC_VER  /*msvc*/

#define PACKSTRUCT( decl ) __pragma( pack(push, 1) ) decl __pragma( pack(pop) )
#define ALIGNED
#else 
#define PACKSTRUCT(a) a PACKED 
#endif
#endif


#define BGLIB_MSG_ID(HDR) ((HDR)&0xffff00f8)
#define BGLIB_MSG_HEADER_LEN (4)
#define BGLIB_MSG_LEN(HDR) ((((HDR)&0x7)<<8)|(((HDR)&0xff00)>>8))


/**
 * Blocks until new event arrives which requires processing by user application.
 * 
 * @return pointer to received event
 */
struct gecko_cmd_packet* gecko_wait_event(void);

/**
 * Same as gecko_wait_event but does not block if no events waiting, instead returns NULL
 *
 * @return pointer to received event or NULL if no event waiting
 */
struct gecko_cmd_packet* gecko_peek_event(void);

/**
 * Events are in queue waiting for processing
 * Call gecko_wait_event or gecko_peek_event to process pending events
 *
 * @return nonzero if processing required
 */
int gecko_event_pending(void);

/**
 *  Initialize stack
 *  @param config if set as NULL uses default values for all configuration parameters
 */
void gecko_stack_init(const gecko_configuration_t *config);



/**
 * Poll the stack how long it can sleep
 * @return maximum sleep time in milliseconds; 0 if cannot sleep
 */
uint32 gecko_can_sleep_ms(void);

/**
 * Poll the stack how long it can sleep
 * @return maximum sleep time in ticks; 0 if cannot sleep
 */
uint32 gecko_can_sleep_ticks(void);

/**
 * Priority message handler function if user application requires the use of PendSV interrupt.
 *
 * If scheduler_callback function pointer in configuration struct is something else than NULL,
 * then stack will not install its own PendSV IRQ handler but instead uses callback/handler functions.
 *
 * When application receives call to the scheduler_callback function it must schedule the call to
 * gecko_priority_handle function to later time to run on high priority thread. This callback
 * may happen inside radio IRQ so processing must not block and has to happen as fast as possible.
 *
 * Recommended implemenation:
 * High priority thread is loop that waits on binary semaphore and calls gecko_priority_handler.
 * The scheduler_callback is simple function that only signals the semaphore.
 *
 */
void gecko_priority_handle(void);

/**
 * Put the stack to sleep for a maximum of @param max milliseconds.
 * Note that the stack may wake up earlier due to an external event.
 * @return number of milliseconds actually slept.
 */
uint32 gecko_sleep_for_ms(uint32 max);

/**
 * Signals stack that external event has happened. Signals can be used to report status change from interrupt
 * context or from other threads to application. Signals are bits that are automatically cleared after
 * application has been notified.
 * 
 * @param signals is a bitmask defining active signals that are reported back to the application by system_external_signal-event.
 *
 */
void gecko_external_signal(uint32 signals);

/**
 * Signals stack to send system_awake event when application received wakeup signal.
 */
void gecko_send_system_awake();




enum le_gap_address_type
{
    le_gap_address_type_public                                   = 0x0,
    le_gap_address_type_random                                   = 0x1,
    le_gap_address_type_public_identity                          = 0x2,
    le_gap_address_type_random_identity                          = 0x3,
    le_gap_address_type_bredr                                    = 0x10
};

enum le_gap_connectable_mode
{
    le_gap_non_connectable                                       = 0x0,
    le_gap_directed_connectable                                  = 0x1,
    le_gap_undirected_connectable                                = 0x2,
    le_gap_scannable_non_connectable                             = 0x3
};

enum le_gap_discoverable_mode
{
    le_gap_non_discoverable                                      = 0x0,
    le_gap_limited_discoverable                                  = 0x1,
    le_gap_general_discoverable                                  = 0x2,
    le_gap_broadcast                                             = 0x3,
    le_gap_user_data                                             = 0x4
};

enum le_gap_discover_mode
{
    le_gap_discover_limited                                      = 0x0,
    le_gap_discover_generic                                      = 0x1,
    le_gap_discover_observation                                  = 0x2
};

enum le_gap_adv_address_type
{
    le_gap_identity_address                                      = 0x0,
    le_gap_non_resolvable                                        = 0x1
};

enum le_connection_security
{
    le_connection_mode1_level1                                   = 0x0,
    le_connection_mode1_level2                                   = 0x1,
    le_connection_mode1_level3                                   = 0x2,
    le_connection_mode1_level4                                   = 0x3
};

enum gatt_att_opcode
{
    gatt_read_by_type_request                                    = 0x8,
    gatt_read_by_type_response                                   = 0x9,
    gatt_read_request                                            = 0xa,
    gatt_read_response                                           = 0xb,
    gatt_read_blob_request                                       = 0xc,
    gatt_read_blob_response                                      = 0xd,
    gatt_read_multiple_request                                   = 0xe,
    gatt_read_multiple_response                                  = 0xf,
    gatt_write_request                                           = 0x12,
    gatt_write_response                                          = 0x13,
    gatt_write_command                                           = 0x52,
    gatt_prepare_write_request                                   = 0x16,
    gatt_prepare_write_response                                  = 0x17,
    gatt_execute_write_request                                   = 0x18,
    gatt_execute_write_response                                  = 0x19,
    gatt_handle_value_notification                               = 0x1b,
    gatt_handle_value_indication                                 = 0x1d
};

enum gatt_client_config_flag
{
    gatt_disable                                                 = 0x0,
    gatt_notification                                            = 0x1,
    gatt_indication                                              = 0x2
};

enum gatt_execute_write_flag
{
    gatt_cancel                                                  = 0x0,
    gatt_commit                                                  = 0x1
};

enum gatt_server_characteristic_status_flag
{
    gatt_server_client_config                                    = 0x1,
    gatt_server_confirmation                                     = 0x2
};

enum endpoint_types
{
    endpoint_free                                                = 0x0,
    endpoint_uart                                                = 0x1,
    endpoint_script                                              = 0x2,
    endpoint_reserved                                            = 0x4,
    endpoint_drop                                                = 0x10,
    endpoint_rfcomm                                              = 0x20,
    endpoint_spi                                                 = 0x40,
    endpoint_connection                                          = 0x80,
    endpoint_native                                              = 0x100
};



enum test_packet_type
{
    test_pkt_prbs9                                               = 0x0,
    test_pkt_11110000                                            = 0x1,
    test_pkt_10101010                                            = 0x2,
    test_pkt_carrier                                             = 0x3,
    test_pkt_pn9                                                 = 0x4
};

enum test_phy
{
    test_phy_1m                                                  = 0x1,
    test_phy_2m                                                  = 0x2,
    test_phy_125k                                                = 0x3,
    test_phy_500k                                                = 0x4
};

enum sm_bonding_key
{
    sm_bonding_key_ltk                                           = 0x1,
    sm_bonding_key_addr_public                                   = 0x2,
    sm_bonding_key_addr_static                                   = 0x4,
    sm_bonding_key_irk                                           = 0x8,
    sm_bonding_key_edivrand                                      = 0x10,
    sm_bonding_key_csrk                                          = 0x20,
    sm_bonding_key_masterid                                      = 0x40
};

enum sm_io_capability
{
    sm_io_capability_displayonly                                 = 0x0,
    sm_io_capability_displayyesno                                = 0x1,
    sm_io_capability_keyboardonly                                = 0x2,
    sm_io_capability_noinputnooutput                             = 0x3,
    sm_io_capability_keyboarddisplay                             = 0x4
};

enum homekit_category
{
    homekit_not_allowed                                          = 0x0,
    homekit_other                                                = 0x1,
    homekit_bridge                                               = 0x2,
    homekit_fan                                                  = 0x3,
    homekit_garage                                               = 0x4,
    homekit_lightbulb                                            = 0x5,
    homekit_doorlock                                             = 0x6,
    homekit_outlet                                               = 0x7,
    homekit_switch_accessory                                     = 0x8,
    homekit_thermostat                                           = 0x9,
    homekit_sensor                                               = 0xa,
    homekit_security_system                                      = 0xb,
    homekit_door                                                 = 0xc,
    homekit_window                                               = 0xd,
    homekit_window_covering                                      = 0xe,
    homekit_programmable_switch                                  = 0xf,
    homekit_range_extender                                       = 0x10,
    homekit_ip_camera                                            = 0x11,
    homekit_video_door_bell                                      = 0x12,
    homekit_air_purifier                                         = 0x13
};

enum homekit_status_code
{
    homekit_success                                              = 0x0,
    homekit_invalid_request                                      = 0x6
};

enum gecko_parameter_types
{
    gecko_msg_parameter_uint8=2,
    gecko_msg_parameter_int8=3,
    gecko_msg_parameter_uint16=4,
    gecko_msg_parameter_int16=5,
    gecko_msg_parameter_uint32=6,
    gecko_msg_parameter_int32=7,
    gecko_msg_parameter_uint8array=8,
    gecko_msg_parameter_string=9,
    gecko_msg_parameter_hwaddr=10,
    gecko_msg_parameter_uint16array=11
};

enum gecko_msg_types
{
    gecko_msg_type_cmd=0x00,
    gecko_msg_type_rsp=0x00,
    gecko_msg_type_evt=0x80
};
enum gecko_dev_types
{
    gecko_dev_type_gecko   =0x20
};



#define ENDPOINT_FLAG_UPDATED                                        0x1
#define ENDPOINT_FLAG_ACTIVE                                         0x2
#define ENDPOINT_FLAG_STREAMING                                      0x4
#define ENDPOINT_FLAG_BGAPI                                          0x8
#define ENDPOINT_FLAG_WAIT_CLOSE                                     0x10
#define ENDPOINT_FLAG_CLOSING                                        0x20
#define FLASH_PS_KEY_BD_ADDR                                         0x1
#define FLASH_PS_KEY_LOCAL_NAME                                      0x4
#define FLASH_PS_KEY_BT_CLASS                                        0x5
#define FLASH_PS_KEY_IWRAP_PAGE_MODE                                 0x6
#define FLASH_PS_KEY_IWRAP_PAGE_TIMEOUT                              0x7
#define FLASH_PS_KEY_IWRAP_PAGE_SCAN_MODE                            0x8
#define FLASH_PS_KEY_IWRAP_ALT_PAGE_MODE                             0x9
#define FLASH_PS_KEY_IWRAP_PAGE_CONN_COUNT                           0xa
#define FLASH_PS_KEY_IWRAP_MS_POLICY                                 0xb
#define FLASH_PS_KEY_IWRAP_LINK_POLICY                               0xc
#define FLASH_PS_KEY_IWRAP_SUPERVISION_TIMEOUT                       0xd
#define FLASH_PS_KEY_SNIFF_MAX_INTERVAL                              0xe
#define FLASH_PS_KEY_SNIFF_MIN_INTERVAL                              0xf
#define FLASH_PS_KEY_SNIFF_ATTEMPTS                                  0x10
#define FLASH_PS_KEY_SNIFF_TIMEOUT                                   0x11
#define FLASH_PS_KEY_IO_CAPABILITIES                                 0x12
#define FLASH_PS_KEY_MITM                                            0x13
#define FLASH_PS_KEY_IWRAP_CONTROL_ECHO                              0x14
#define FLASH_PS_KEY_UART_SPEED                                      0x15
#define FLASH_PS_KEY_PROFILE_SPP                                     0x16
#define FLASH_PS_KEY_PORTA_PIO_DIRECTION                             0x17
#define FLASH_PS_KEY_PORTB_PIO_DIRECTION                             0x18
#define FLASH_PS_KEY_PORTA_PIO_BIAS                                  0x19
#define FLASH_PS_KEY_PORTB_PIO_BIAS                                  0x1a
#define FLASH_PS_KEY_PORTA_PIO_PULL_UP                               0x1b
#define FLASH_PS_KEY_PORTB_PIO_PULL_UP                               0x1c
#define FLASH_PS_KEY_IWRAP_I2C_STATUS                                0x1d
#define FLASH_PS_KEY_IWRAP_SPI_STATUS                                0x1e
#define FLASH_PS_KEY_MAXPAIRCOUNT                                    0x1f
#define FLASH_PS_KEY_LAST_DELETED_PAIR                               0x20
#define FLASH_PS_KEY_IWRAP_CD_MASK                                   0x21
#define FLASH_PS_KEY_IWRAP_CD_DATA_MASK                              0x22
#define FLASH_PS_KEY_IWRAP_CD_MODE                                   0x23
#define FLASH_PS_KEY_IWRAP_AUTH_PIN_VISIBLE                          0x24
#define FLASH_PS_KEY_AUTH_PIN                                        0x25
#define FLASH_PS_KEY_IWRAP_READY_MASK                                0x26
#define FLASH_PS_KEY_IWRAP_ESC_CHAR                                  0x27
#define FLASH_PS_KEY_IWRAP_DTR_PIO_MASK                              0x28
#define FLASH_PS_KEY_IWRAP_DTR_MODE                                  0x29
#define FLASH_PS_KEY_MINIMUM_ENCRYPTION_KEY_SIZE                     0x2a
#define FLASH_PS_KEY_INQUIRY_SCAN_LAP                                0x2b
#define FLASH_PS_KEY_LOCAL_BD_ADDR                                   0x2c
#define FLASH_PS_KEY_AUTOCALL                                        0x2d
#define FLASH_PS_KEY_AUTOCALL_DUMMY                                  0x2e
#define FLASH_PS_KEY_LAP                                             0x2f
#define FLASH_PS_KEY_CONNAUTH                                        0x30
#define FLASH_PS_KEY_TX_POWER                                        0x31
#define FLASH_PS_KEY_CTUNE                                           0x32
#define FLASH_PS_KEY_APPLICATION_GSN                                 0x33
#define FLASH_PS_KEY_CTUNE_LAST                                      0x34
#define FLASH_PS_KEY_OTA_FLAGS                                       0x35
#define FLASH_PS_KEY_OTA_DEVICE_NAME                                 0x36
#define FLASH_PS_KEY_DEVICE_IRK                                      0x37
#define FLASH_PS_KEY_BONDING_PRIORITY_LIST                           0x38
#define FLASH_PS_KEY_BONDING_DB_CONFIG                               0x3fff


#define gecko_cmd_dfu_reset_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00000000)
#define gecko_cmd_dfu_flash_set_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01000000)
#define gecko_cmd_dfu_flash_upload_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02000000)
#define gecko_cmd_dfu_flash_upload_finish_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03000000)
#define gecko_cmd_system_hello_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00010000)
#define gecko_cmd_system_reset_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01010000)
#define gecko_cmd_system_get_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03010000)
#define gecko_cmd_system_set_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04010000)
#define gecko_cmd_system_set_tx_power_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a010000)
#define gecko_cmd_system_get_random_data_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b010000)
#define gecko_cmd_system_halt_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c010000)
#define gecko_cmd_system_set_device_name_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d010000)
#define gecko_cmd_le_gap_open_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00030000)
#define gecko_cmd_le_gap_set_mode_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01030000)
#define gecko_cmd_le_gap_discover_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02030000)
#define gecko_cmd_le_gap_end_procedure_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03030000)
#define gecko_cmd_le_gap_set_adv_parameters_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04030000)
#define gecko_cmd_le_gap_set_conn_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05030000)
#define gecko_cmd_le_gap_set_scan_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06030000)
#define gecko_cmd_le_gap_set_adv_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07030000)
#define gecko_cmd_le_gap_set_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08030000)
#define gecko_cmd_le_gap_set_phy_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09030000)
#define gecko_cmd_le_gap_bt5_set_mode_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a030000)
#define gecko_cmd_le_gap_bt5_set_adv_parameters_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b030000)
#define gecko_cmd_le_gap_bt5_set_adv_data_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c030000)
#define gecko_cmd_le_gap_set_privacy_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d030000)
#define gecko_cmd_le_connection_set_parameters_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00080000)
#define gecko_cmd_le_connection_get_rssi_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01080000)
#define gecko_cmd_le_connection_disable_slave_latency_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02080000)
#define gecko_cmd_le_connection_set_phy_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03080000)
#define gecko_cmd_gatt_set_max_mtu_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00090000)
#define gecko_cmd_gatt_discover_primary_services_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01090000)
#define gecko_cmd_gatt_discover_primary_services_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02090000)
#define gecko_cmd_gatt_discover_characteristics_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03090000)
#define gecko_cmd_gatt_discover_characteristics_by_uuid_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04090000)
#define gecko_cmd_gatt_set_characteristic_notification_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05090000)
#define gecko_cmd_gatt_discover_descriptors_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06090000)
#define gecko_cmd_gatt_read_characteristic_value_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07090000)
#define gecko_cmd_gatt_read_characteristic_value_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08090000)
#define gecko_cmd_gatt_write_characteristic_value_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x09090000)
#define gecko_cmd_gatt_write_characteristic_value_without_response_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a090000)
#define gecko_cmd_gatt_prepare_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b090000)
#define gecko_cmd_gatt_execute_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c090000)
#define gecko_cmd_gatt_send_characteristic_confirmation_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d090000)
#define gecko_cmd_gatt_read_descriptor_value_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e090000)
#define gecko_cmd_gatt_write_descriptor_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f090000)
#define gecko_cmd_gatt_find_included_services_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x10090000)
#define gecko_cmd_gatt_read_multiple_characteristic_values_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x11090000)
#define gecko_cmd_gatt_read_characteristic_value_from_offset_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x12090000)
#define gecko_cmd_gatt_prepare_characteristic_value_reliable_write_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x13090000)
#define gecko_cmd_gatt_server_read_attribute_value_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000a0000)
#define gecko_cmd_gatt_server_read_attribute_type_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010a0000)
#define gecko_cmd_gatt_server_write_attribute_value_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020a0000)
#define gecko_cmd_gatt_server_send_user_read_response_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030a0000)
#define gecko_cmd_gatt_server_send_user_write_response_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040a0000)
#define gecko_cmd_gatt_server_send_characteristic_notification_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050a0000)
#define gecko_cmd_gatt_server_find_attribute_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060a0000)
#define gecko_cmd_gatt_server_set_database_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070a0000)
#define gecko_cmd_gatt_server_set_capabilities_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080a0000)
#define gecko_cmd_endpoint_send_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000b0000)
#define gecko_cmd_endpoint_set_streaming_destination_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010b0000)
#define gecko_cmd_endpoint_close_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020b0000)
#define gecko_cmd_endpoint_set_flags_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030b0000)
#define gecko_cmd_endpoint_clr_flags_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040b0000)
#define gecko_cmd_endpoint_read_counters_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x050b0000)
#define gecko_cmd_hardware_set_soft_timer_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000c0000)
#define gecko_cmd_hardware_get_time_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0c0000)
#define gecko_cmd_hardware_set_lazy_soft_timer_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c0c0000)
#define gecko_cmd_hardware_enable_dcdc_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0d0c0000)
#define gecko_cmd_flash_ps_dump_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000d0000)
#define gecko_cmd_flash_ps_erase_all_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010d0000)
#define gecko_cmd_flash_ps_save_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020d0000)
#define gecko_cmd_flash_ps_load_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x030d0000)
#define gecko_cmd_flash_ps_erase_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040d0000)
#define gecko_cmd_test_dtm_tx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000e0000)
#define gecko_cmd_test_dtm_rx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010e0000)
#define gecko_cmd_test_dtm_end_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020e0000)
#define gecko_cmd_test_debug_command_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070e0000)
#define gecko_cmd_test_debug_counter_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0c0e0000)
#define gecko_cmd_sm_set_bondable_mode_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x000f0000)
#define gecko_cmd_sm_configure_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x010f0000)
#define gecko_cmd_sm_store_bonding_configuration_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x020f0000)
#define gecko_cmd_sm_increase_security_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x040f0000)
#define gecko_cmd_sm_delete_bonding_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x060f0000)
#define gecko_cmd_sm_delete_bondings_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x070f0000)
#define gecko_cmd_sm_enter_passkey_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x080f0000)
#define gecko_cmd_sm_passkey_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x090f0000)
#define gecko_cmd_sm_set_oob_data_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0a0f0000)
#define gecko_cmd_sm_list_all_bondings_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0b0f0000)
#define gecko_cmd_sm_bonding_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0e0f0000)
#define gecko_cmd_sm_set_debug_mode_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x0f0f0000)
#define gecko_cmd_sm_set_passkey_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x100f0000)
#define gecko_cmd_sm_use_sc_oob_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x110f0000)
#define gecko_cmd_sm_set_sc_remote_oob_data_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x120f0000)
#define gecko_cmd_homekit_configure_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00130000)
#define gecko_cmd_homekit_advertise_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x01130000)
#define gecko_cmd_homekit_delete_pairings_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x02130000)
#define gecko_cmd_homekit_check_authcp_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x03130000)
#define gecko_cmd_homekit_get_pairing_id_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x04130000)
#define gecko_cmd_homekit_send_write_response_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x05130000)
#define gecko_cmd_homekit_send_read_response_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x06130000)
#define gecko_cmd_homekit_gsn_action_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x07130000)
#define gecko_cmd_homekit_event_notification_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x08130000)
#define gecko_cmd_user_message_to_target_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_cmd|0x00ff0000)

#define gecko_rsp_dfu_flash_set_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01000000)
#define gecko_rsp_dfu_flash_upload_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02000000)
#define gecko_rsp_dfu_flash_upload_finish_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03000000)
#define gecko_rsp_system_hello_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00010000)
#define gecko_rsp_system_get_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03010000)
#define gecko_rsp_system_set_bt_address_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04010000)
#define gecko_rsp_system_set_tx_power_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a010000)
#define gecko_rsp_system_get_random_data_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b010000)
#define gecko_rsp_system_halt_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c010000)
#define gecko_rsp_system_set_device_name_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d010000)
#define gecko_rsp_le_gap_open_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00030000)
#define gecko_rsp_le_gap_set_mode_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01030000)
#define gecko_rsp_le_gap_discover_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02030000)
#define gecko_rsp_le_gap_end_procedure_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03030000)
#define gecko_rsp_le_gap_set_adv_parameters_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04030000)
#define gecko_rsp_le_gap_set_conn_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05030000)
#define gecko_rsp_le_gap_set_scan_parameters_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06030000)
#define gecko_rsp_le_gap_set_adv_data_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07030000)
#define gecko_rsp_le_gap_set_adv_timeout_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08030000)
#define gecko_rsp_le_gap_set_phy_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09030000)
#define gecko_rsp_le_gap_bt5_set_mode_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a030000)
#define gecko_rsp_le_gap_bt5_set_adv_parameters_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b030000)
#define gecko_rsp_le_gap_bt5_set_adv_data_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c030000)
#define gecko_rsp_le_gap_set_privacy_mode_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d030000)
#define gecko_rsp_le_connection_set_parameters_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00080000)
#define gecko_rsp_le_connection_get_rssi_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01080000)
#define gecko_rsp_le_connection_disable_slave_latency_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02080000)
#define gecko_rsp_le_connection_set_phy_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03080000)
#define gecko_rsp_gatt_set_max_mtu_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00090000)
#define gecko_rsp_gatt_discover_primary_services_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01090000)
#define gecko_rsp_gatt_discover_primary_services_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02090000)
#define gecko_rsp_gatt_discover_characteristics_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03090000)
#define gecko_rsp_gatt_discover_characteristics_by_uuid_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04090000)
#define gecko_rsp_gatt_set_characteristic_notification_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05090000)
#define gecko_rsp_gatt_discover_descriptors_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06090000)
#define gecko_rsp_gatt_read_characteristic_value_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07090000)
#define gecko_rsp_gatt_read_characteristic_value_by_uuid_id           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08090000)
#define gecko_rsp_gatt_write_characteristic_value_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x09090000)
#define gecko_rsp_gatt_write_characteristic_value_without_response_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a090000)
#define gecko_rsp_gatt_prepare_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b090000)
#define gecko_rsp_gatt_execute_characteristic_value_write_id          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c090000)
#define gecko_rsp_gatt_send_characteristic_confirmation_id            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d090000)
#define gecko_rsp_gatt_read_descriptor_value_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e090000)
#define gecko_rsp_gatt_write_descriptor_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f090000)
#define gecko_rsp_gatt_find_included_services_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x10090000)
#define gecko_rsp_gatt_read_multiple_characteristic_values_id         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x11090000)
#define gecko_rsp_gatt_read_characteristic_value_from_offset_id       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x12090000)
#define gecko_rsp_gatt_prepare_characteristic_value_reliable_write_id  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x13090000)
#define gecko_rsp_gatt_server_read_attribute_value_id                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000a0000)
#define gecko_rsp_gatt_server_read_attribute_type_id                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010a0000)
#define gecko_rsp_gatt_server_write_attribute_value_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020a0000)
#define gecko_rsp_gatt_server_send_user_read_response_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030a0000)
#define gecko_rsp_gatt_server_send_user_write_response_id             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040a0000)
#define gecko_rsp_gatt_server_send_characteristic_notification_id     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050a0000)
#define gecko_rsp_gatt_server_find_attribute_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060a0000)
#define gecko_rsp_gatt_server_set_database_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070a0000)
#define gecko_rsp_gatt_server_set_capabilities_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080a0000)
#define gecko_rsp_endpoint_send_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000b0000)
#define gecko_rsp_endpoint_set_streaming_destination_id               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010b0000)
#define gecko_rsp_endpoint_close_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020b0000)
#define gecko_rsp_endpoint_set_flags_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030b0000)
#define gecko_rsp_endpoint_clr_flags_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040b0000)
#define gecko_rsp_endpoint_read_counters_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x050b0000)
#define gecko_rsp_hardware_set_soft_timer_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000c0000)
#define gecko_rsp_hardware_get_time_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0c0000)
#define gecko_rsp_hardware_set_lazy_soft_timer_id                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c0c0000)
#define gecko_rsp_hardware_enable_dcdc_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0d0c0000)
#define gecko_rsp_flash_ps_dump_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000d0000)
#define gecko_rsp_flash_ps_erase_all_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010d0000)
#define gecko_rsp_flash_ps_save_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020d0000)
#define gecko_rsp_flash_ps_load_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x030d0000)
#define gecko_rsp_flash_ps_erase_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040d0000)
#define gecko_rsp_test_dtm_tx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000e0000)
#define gecko_rsp_test_dtm_rx_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010e0000)
#define gecko_rsp_test_dtm_end_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020e0000)
#define gecko_rsp_test_debug_command_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070e0000)
#define gecko_rsp_test_debug_counter_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0c0e0000)
#define gecko_rsp_sm_set_bondable_mode_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x000f0000)
#define gecko_rsp_sm_configure_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x010f0000)
#define gecko_rsp_sm_store_bonding_configuration_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x020f0000)
#define gecko_rsp_sm_increase_security_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x040f0000)
#define gecko_rsp_sm_delete_bonding_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x060f0000)
#define gecko_rsp_sm_delete_bondings_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x070f0000)
#define gecko_rsp_sm_enter_passkey_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x080f0000)
#define gecko_rsp_sm_passkey_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x090f0000)
#define gecko_rsp_sm_set_oob_data_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0a0f0000)
#define gecko_rsp_sm_list_all_bondings_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0b0f0000)
#define gecko_rsp_sm_bonding_confirm_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0e0f0000)
#define gecko_rsp_sm_set_debug_mode_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x0f0f0000)
#define gecko_rsp_sm_set_passkey_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x100f0000)
#define gecko_rsp_sm_use_sc_oob_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x110f0000)
#define gecko_rsp_sm_set_sc_remote_oob_data_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x120f0000)
#define gecko_rsp_homekit_configure_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00130000)
#define gecko_rsp_homekit_advertise_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x01130000)
#define gecko_rsp_homekit_delete_pairings_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x02130000)
#define gecko_rsp_homekit_check_authcp_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x03130000)
#define gecko_rsp_homekit_get_pairing_id_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x04130000)
#define gecko_rsp_homekit_send_write_response_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x05130000)
#define gecko_rsp_homekit_send_read_response_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x06130000)
#define gecko_rsp_homekit_gsn_action_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x07130000)
#define gecko_rsp_homekit_event_notification_id                       (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x08130000)
#define gecko_rsp_user_message_to_target_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_rsp|0x00ff0000)

#define gecko_evt_dfu_boot_id                                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00000000)
#define gecko_evt_dfu_boot_failure_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01000000)
#define gecko_evt_system_boot_id                                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00010000)
#define gecko_evt_system_external_signal_id                           (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03010000)
#define gecko_evt_system_awake_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04010000)
#define gecko_evt_system_hardware_error_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05010000)
#define gecko_evt_le_gap_scan_response_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00030000)
#define gecko_evt_le_gap_adv_timeout_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01030000)
#define gecko_evt_le_gap_scan_request_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02030000)
#define gecko_evt_le_connection_opened_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00080000)
#define gecko_evt_le_connection_closed_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01080000)
#define gecko_evt_le_connection_parameters_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02080000)
#define gecko_evt_le_connection_rssi_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03080000)
#define gecko_evt_le_connection_phy_status_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04080000)
#define gecko_evt_le_connection_bt5_opened_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05080000)
#define gecko_evt_gatt_mtu_exchanged_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00090000)
#define gecko_evt_gatt_service_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01090000)
#define gecko_evt_gatt_characteristic_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02090000)
#define gecko_evt_gatt_descriptor_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03090000)
#define gecko_evt_gatt_characteristic_value_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04090000)
#define gecko_evt_gatt_descriptor_value_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05090000)
#define gecko_evt_gatt_procedure_completed_id                         (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06090000)
#define gecko_evt_gatt_server_attribute_value_id                      (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000a0000)
#define gecko_evt_gatt_server_user_read_request_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010a0000)
#define gecko_evt_gatt_server_user_write_request_id                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020a0000)
#define gecko_evt_gatt_server_characteristic_status_id                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030a0000)
#define gecko_evt_gatt_server_execute_write_completed_id              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040a0000)
#define gecko_evt_endpoint_syntax_error_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000b0000)
#define gecko_evt_endpoint_data_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010b0000)
#define gecko_evt_endpoint_status_id                                  (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020b0000)
#define gecko_evt_hardware_soft_timer_id                              (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000c0000)
#define gecko_evt_flash_ps_key_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000d0000)
#define gecko_evt_test_dtm_completed_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000e0000)
#define gecko_evt_test_hcidump_id                                     (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020e0000)
#define gecko_evt_sm_passkey_display_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x000f0000)
#define gecko_evt_sm_passkey_request_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x010f0000)
#define gecko_evt_sm_confirm_passkey_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x020f0000)
#define gecko_evt_sm_bonded_id                                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x030f0000)
#define gecko_evt_sm_bonding_failed_id                                (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x040f0000)
#define gecko_evt_sm_list_bonding_entry_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x050f0000)
#define gecko_evt_sm_list_all_bondings_complete_id                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x060f0000)
#define gecko_evt_sm_confirm_bonding_id                               (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x090f0000)
#define gecko_evt_homekit_setupcode_display_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00130000)
#define gecko_evt_homekit_paired_id                                   (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x01130000)
#define gecko_evt_homekit_pair_verified_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x02130000)
#define gecko_evt_homekit_connection_opened_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x03130000)
#define gecko_evt_homekit_connection_closed_id                        (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x04130000)
#define gecko_evt_homekit_identify_id                                 (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x05130000)
#define gecko_evt_homekit_write_request_id                            (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x06130000)
#define gecko_evt_homekit_read_request_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x07130000)
#define gecko_evt_homekit_error_id                                    (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x08130000)
#define gecko_evt_homekit_pairing_removed_id                          (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x09130000)
#define gecko_evt_user_message_to_host_id                             (((uint32)gecko_dev_type_gecko)|gecko_msg_type_evt|0x00ff0000)

#include "bg_errorcodes.h"

PACKSTRUCT( struct gecko_msg_dfu_reset_cmd_t
{
    uint8               dfu;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_cmd_t
{
    uint32              address;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_set_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_flash_upload_finish_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_dfu_boot_evt_t
{
    uint32              version;
});
PACKSTRUCT( struct gecko_msg_dfu_boot_failure_evt_t
{
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_system_hello_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_reset_cmd_t
{
    uint8               dfu;
});
PACKSTRUCT( struct gecko_msg_system_get_bt_address_rsp_t
{
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_system_set_bt_address_cmd_t
{
    bd_addr             address;
});
PACKSTRUCT( struct gecko_msg_system_set_bt_address_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_tx_power_cmd_t
{
    int16               power;
});
PACKSTRUCT( struct gecko_msg_system_set_tx_power_rsp_t
{
    int16               set_power;
});
PACKSTRUCT( struct gecko_msg_system_get_random_data_cmd_t
{
    uint8               length;
});
PACKSTRUCT( struct gecko_msg_system_get_random_data_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_system_halt_cmd_t
{
    uint8               halt;
});
PACKSTRUCT( struct gecko_msg_system_halt_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_set_device_name_cmd_t
{
    uint8               type;
    uint8array          name;
});
PACKSTRUCT( struct gecko_msg_system_set_device_name_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_system_boot_evt_t
{
    uint16              major;
    uint16              minor;
    uint16              patch;
    uint16              build;
    uint32              bootloader;
    uint16              hw;
});
PACKSTRUCT( struct gecko_msg_system_external_signal_evt_t
{
    uint32              extsignals;
});
PACKSTRUCT( struct gecko_msg_system_hardware_error_evt_t
{
    uint16              status;
});
PACKSTRUCT( struct gecko_msg_le_gap_open_cmd_t
{
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_open_rsp_t
{
    uint16              result;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_mode_cmd_t
{
    uint8               discover;
    uint8               connect;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_discover_cmd_t
{
    uint8               mode;
});
PACKSTRUCT( struct gecko_msg_le_gap_discover_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_end_procedure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_cmd_t
{
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_cmd_t
{
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_conn_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_cmd_t
{
    uint16              scan_interval;
    uint16              scan_window;
    uint8               active;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_scan_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_cmd_t
{
    uint8               scan_rsp;
    uint8array          adv_data;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_cmd_t
{
    uint8               intervals;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_adv_timeout_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_phy_cmd_t
{
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_mode_cmd_t
{
    uint8               handle;
    uint8               discover;
    uint8               connect;
    uint16              maxevents;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_parameters_cmd_t
{
    uint8               handle;
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
    uint8               report_scan;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_data_cmd_t
{
    uint8               handle;
    uint8               scan_rsp;
    uint8array          adv_data;
});
PACKSTRUCT( struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_privacy_mode_cmd_t
{
    uint8               privacy;
    uint8               interval;
});
PACKSTRUCT( struct gecko_msg_le_gap_set_privacy_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_gap_scan_response_evt_t
{
    int8                rssi;
    uint8               packet_type;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_le_gap_scan_request_evt_t
{
    uint8               handle;
    bd_addr             address;
    uint8               address_type;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_cmd_t
{
    uint8               connection;
    uint16              min_interval;
    uint16              max_interval;
    uint16              latency;
    uint16              timeout;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_parameters_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_get_rssi_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_cmd_t
{
    uint8               connection;
    uint8               disable;
});
PACKSTRUCT( struct gecko_msg_le_connection_disable_slave_latency_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_phy_cmd_t
{
    uint8               connection;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_connection_set_phy_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_le_connection_opened_evt_t
{
    bd_addr             address;
    uint8               address_type;
    uint8               master;
    uint8               connection;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_le_connection_closed_evt_t
{
    uint16              reason;
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_le_connection_parameters_evt_t
{
    uint8               connection;
    uint16              interval;
    uint16              latency;
    uint16              timeout;
    uint8               security_mode;
    uint16              txsize;
});
PACKSTRUCT( struct gecko_msg_le_connection_rssi_evt_t
{
    uint8               connection;
    uint8               status;
    int8                rssi;
});
PACKSTRUCT( struct gecko_msg_le_connection_phy_status_evt_t
{
    uint8               connection;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_le_connection_bt5_opened_evt_t
{
    bd_addr             address;
    uint8               address_type;
    uint8               master;
    uint8               connection;
    uint8               bonding;
    uint8               advertiser;
});
PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_cmd_t
{
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_set_max_mtu_rsp_t
{
    uint16              result;
    uint16              max_mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t
{
    uint8               connection;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_cmd_t
{
    uint8               connection;
    uint32              service;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_gatt_set_characteristic_notification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_cmd_t
{
    uint8               connection;
    uint16              characteristic;
});
PACKSTRUCT( struct gecko_msg_gatt_discover_descriptors_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_cmd_t
{
    uint8               connection;
    uint16              characteristic;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t
{
    uint8               connection;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_cmd_t
{
    uint8               connection;
    uint16              descriptor;
});
PACKSTRUCT( struct gecko_msg_gatt_read_descriptor_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_cmd_t
{
    uint8               connection;
    uint16              descriptor;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_write_descriptor_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_find_included_services_cmd_t
{
    uint8               connection;
    uint32              service;
});
PACKSTRUCT( struct gecko_msg_gatt_find_included_services_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t
{
    uint8               connection;
    uint8array          characteristic_list;
});
PACKSTRUCT( struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_from_offset_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint16              maxlen;
});
PACKSTRUCT( struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_mtu_exchanged_evt_t
{
    uint8               connection;
    uint16              mtu;
});
PACKSTRUCT( struct gecko_msg_gatt_service_evt_t
{
    uint8               connection;
    uint32              service;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_characteristic_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               properties;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_descriptor_evt_t
{
    uint8               connection;
    uint16              descriptor;
    uint8array          uuid;
});
PACKSTRUCT( struct gecko_msg_gatt_characteristic_value_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_descriptor_value_evt_t
{
    uint8               connection;
    uint16              descriptor;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_procedure_completed_evt_t
{
    uint8               connection;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_cmd_t
{
    uint16              attribute;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_value_rsp_t
{
    uint16              result;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_cmd_t
{
    uint16              attribute;
});
PACKSTRUCT( struct gecko_msg_gatt_server_read_attribute_type_rsp_t
{
    uint16              result;
    uint8array          type;
});
PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_cmd_t
{
    uint16              attribute;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_write_attribute_value_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_errorcode;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_read_response_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_errorcode;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_user_write_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t
{
    uint16              result;
    uint16              sent_len;
});
PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_cmd_t
{
    uint16              start;
    uint8array          type;
});
PACKSTRUCT( struct gecko_msg_gatt_server_find_attribute_rsp_t
{
    uint16              result;
    uint16              attribute;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_database_cmd_t
{
    uint32              ptr;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_database_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_capabilities_cmd_t
{
    uint32              caps;
    uint32              reserved;
});
PACKSTRUCT( struct gecko_msg_gatt_server_set_capabilities_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_gatt_server_attribute_value_evt_t
{
    uint8               connection;
    uint16              attribute;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_user_read_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_gatt_server_user_write_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               att_opcode;
    uint16              offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_gatt_server_characteristic_status_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_flags;
    uint16              client_config_flags;
});
PACKSTRUCT( struct gecko_msg_gatt_server_execute_write_completed_evt_t
{
    uint8               connection;
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_endpoint_send_cmd_t
{
    uint8               endpoint;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_endpoint_send_rsp_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_set_streaming_destination_cmd_t
{
    uint8               endpoint;
    uint8               destination_endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_set_streaming_destination_rsp_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_close_cmd_t
{
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_close_rsp_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_set_flags_cmd_t
{
    uint8               endpoint;
    uint32              flags;
});
PACKSTRUCT( struct gecko_msg_endpoint_set_flags_rsp_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_clr_flags_cmd_t
{
    uint8               endpoint;
    uint32              flags;
});
PACKSTRUCT( struct gecko_msg_endpoint_clr_flags_rsp_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_read_counters_cmd_t
{
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_read_counters_rsp_t
{
    uint16              result;
    uint8               endpoint;
    uint32              tx;
    uint32              rx;
});
PACKSTRUCT( struct gecko_msg_endpoint_syntax_error_evt_t
{
    uint16              result;
    uint8               endpoint;
});
PACKSTRUCT( struct gecko_msg_endpoint_data_evt_t
{
    uint8               endpoint;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_endpoint_status_evt_t
{
    uint8               endpoint;
    uint32              type;
    int8                destination_endpoint;
    uint8               flags;
});
PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_cmd_t
{
    uint32              time;
    uint8               handle;
    uint8               single_shot;
});
PACKSTRUCT( struct gecko_msg_hardware_set_soft_timer_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_get_time_rsp_t
{
    uint32              seconds;
    uint16              ticks;
});
PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t
{
    uint32              time;
    uint32              slack;
    uint8               handle;
    uint8               single_shot;
});
PACKSTRUCT( struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_enable_dcdc_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_hardware_enable_dcdc_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_hardware_soft_timer_evt_t
{
    uint8               handle;
});
PACKSTRUCT( struct gecko_msg_flash_ps_dump_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_all_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_save_cmd_t
{
    uint16              key;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_flash_ps_save_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_load_cmd_t
{
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_flash_ps_load_rsp_t
{
    uint16              result;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_cmd_t
{
    uint16              key;
});
PACKSTRUCT( struct gecko_msg_flash_ps_erase_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_flash_ps_key_evt_t
{
    uint16              key;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_test_dtm_tx_cmd_t
{
    uint8               packet_type;
    uint8               length;
    uint8               channel;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_test_dtm_tx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_rx_cmd_t
{
    uint8               channel;
    uint8               phy;
});
PACKSTRUCT( struct gecko_msg_test_dtm_rx_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_dtm_end_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_test_debug_command_cmd_t
{
    uint8               id;
    uint8array          debugdata;
});
PACKSTRUCT( struct gecko_msg_test_debug_command_rsp_t
{
    uint16              result;
    uint8               id;
    uint8array          debugdata;
});
PACKSTRUCT( struct gecko_msg_test_debug_counter_cmd_t
{
    uint32              id;
});
PACKSTRUCT( struct gecko_msg_test_debug_counter_rsp_t
{
    uint16              result;
    uint32              value;
});
PACKSTRUCT( struct gecko_msg_test_dtm_completed_evt_t
{
    uint16              result;
    uint16              number_of_packets;
});
PACKSTRUCT( struct gecko_msg_test_hcidump_evt_t
{
    uint32              time;
    uint8               direction;
    uint8               packet_type;
    uint16array         data;
});
PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_cmd_t
{
    uint8               bondable;
});
PACKSTRUCT( struct gecko_msg_sm_set_bondable_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_configure_cmd_t
{
    uint8               flags;
    uint8               io_capabilities;
});
PACKSTRUCT( struct gecko_msg_sm_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_cmd_t
{
    uint8               max_bonding_count;
    uint8               policy_flags;
});
PACKSTRUCT( struct gecko_msg_sm_store_bonding_configuration_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_increase_security_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_sm_increase_security_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bonding_cmd_t
{
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bonding_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_delete_bondings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_enter_passkey_cmd_t
{
    uint8               connection;
    int32               passkey;
});
PACKSTRUCT( struct gecko_msg_sm_enter_passkey_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_cmd_t
{
    uint8               connection;
    uint8               confirm;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_confirm_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_oob_data_cmd_t
{
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_oob_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_list_all_bondings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_confirm_cmd_t
{
    uint8               connection;
    uint8               confirm;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_confirm_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_debug_mode_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_set_passkey_cmd_t
{
    int32               passkey;
});
PACKSTRUCT( struct gecko_msg_sm_set_passkey_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_use_sc_oob_cmd_t
{
    uint8               enable;
});
PACKSTRUCT( struct gecko_msg_sm_use_sc_oob_rsp_t
{
    uint16              result;
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_sc_remote_oob_data_cmd_t
{
    uint8array          oob_data;
});
PACKSTRUCT( struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_display_evt_t
{
    uint8               connection;
    uint32              passkey;
});
PACKSTRUCT( struct gecko_msg_sm_passkey_request_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_sm_confirm_passkey_evt_t
{
    uint8               connection;
    uint32              passkey;
});
PACKSTRUCT( struct gecko_msg_sm_bonded_evt_t
{
    uint8               connection;
    uint8               bonding;
});
PACKSTRUCT( struct gecko_msg_sm_bonding_failed_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_sm_list_bonding_entry_evt_t
{
    uint8               bonding;
    bd_addr             address;
    uint8               address_type;
});
PACKSTRUCT( struct gecko_msg_sm_confirm_bonding_evt_t
{
    uint8               connection;
    int8                bonding_handle;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_cmd_t
{
    uint8               i2c_address;
    uint8               support_display;
    uint8               hap_attribute_features;
    uint16              category;
    uint8               configuration_number;
    uint16              fast_advert_interval;
    uint16              fast_advert_timeout;
    uint32              flag;
});
PACKSTRUCT( struct gecko_msg_homekit_configure_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_advertise_cmd_t
{
    uint8               enable;
    uint16              interval_min;
    uint16              interval_max;
    uint8               channel_map;
});
PACKSTRUCT( struct gecko_msg_homekit_advertise_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_delete_pairings_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_check_authcp_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_cmd_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_get_pairing_id_rsp_t
{
    uint16              result;
    uint8array          pairing_id;
});
PACKSTRUCT( struct gecko_msg_homekit_send_write_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_code;
});
PACKSTRUCT( struct gecko_msg_homekit_send_write_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_send_read_response_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               status_code;
    uint16              attribute_size;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_send_read_response_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_gsn_action_cmd_t
{
    uint8               action;
});
PACKSTRUCT( struct gecko_msg_homekit_gsn_action_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_event_notification_cmd_t
{
    uint8               connection;
    uint16              characteristic;
    uint8               change_originator;
});
PACKSTRUCT( struct gecko_msg_homekit_event_notification_rsp_t
{
    uint16              result;
});
PACKSTRUCT( struct gecko_msg_homekit_setupcode_display_evt_t
{
    uint8               connection;
    uint8array          setupcode;
});
PACKSTRUCT( struct gecko_msg_homekit_paired_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_pair_verified_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_connection_opened_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_connection_closed_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_identify_evt_t
{
    uint8               connection;
});
PACKSTRUCT( struct gecko_msg_homekit_write_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              chr_value_size;
    uint16              authorization_size;
    uint16              value_offset;
    uint8array          value;
});
PACKSTRUCT( struct gecko_msg_homekit_read_request_evt_t
{
    uint8               connection;
    uint16              characteristic;
    uint16              offset;
});
PACKSTRUCT( struct gecko_msg_homekit_error_evt_t
{
    uint8               connection;
    uint16              reason;
});
PACKSTRUCT( struct gecko_msg_homekit_pairing_removed_evt_t
{
    uint8               connection;
    uint16              remaining_pairings;
    uint8array          pairing_id;
});
PACKSTRUCT( struct gecko_msg_user_message_to_target_cmd_t
{
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_user_message_to_target_rsp_t
{
    uint16              result;
    uint8array          data;
});
PACKSTRUCT( struct gecko_msg_user_message_to_host_evt_t
{
    uint8array          data;
});


/**
 * The command packet type. This does not include the actual size of the byte array for user data in the end of the message.
 * The full size of a command packet is 4 + max bgapi payload size.
 */
PACKSTRUCT( struct gecko_cmd_packet
{
    uint32   header;

union{
    uint8 handle;
    struct gecko_msg_dfu_reset_cmd_t                             cmd_dfu_reset;
    struct gecko_msg_dfu_flash_set_address_cmd_t                 cmd_dfu_flash_set_address;
    struct gecko_msg_dfu_flash_set_address_rsp_t                 rsp_dfu_flash_set_address;
    struct gecko_msg_dfu_flash_upload_cmd_t                      cmd_dfu_flash_upload;
    struct gecko_msg_dfu_flash_upload_rsp_t                      rsp_dfu_flash_upload;
    struct gecko_msg_dfu_flash_upload_finish_rsp_t               rsp_dfu_flash_upload_finish;
    struct gecko_msg_dfu_boot_evt_t                              evt_dfu_boot;
    struct gecko_msg_dfu_boot_failure_evt_t                      evt_dfu_boot_failure;
    struct gecko_msg_system_hello_rsp_t                          rsp_system_hello;
    struct gecko_msg_system_reset_cmd_t                          cmd_system_reset;
    struct gecko_msg_system_get_bt_address_rsp_t                 rsp_system_get_bt_address;
    struct gecko_msg_system_set_bt_address_cmd_t                 cmd_system_set_bt_address;
    struct gecko_msg_system_set_bt_address_rsp_t                 rsp_system_set_bt_address;
    struct gecko_msg_system_set_tx_power_cmd_t                   cmd_system_set_tx_power;
    struct gecko_msg_system_set_tx_power_rsp_t                   rsp_system_set_tx_power;
    struct gecko_msg_system_get_random_data_cmd_t                cmd_system_get_random_data;
    struct gecko_msg_system_get_random_data_rsp_t                rsp_system_get_random_data;
    struct gecko_msg_system_halt_cmd_t                           cmd_system_halt;
    struct gecko_msg_system_halt_rsp_t                           rsp_system_halt;
    struct gecko_msg_system_set_device_name_cmd_t                cmd_system_set_device_name;
    struct gecko_msg_system_set_device_name_rsp_t                rsp_system_set_device_name;
    struct gecko_msg_system_boot_evt_t                           evt_system_boot;
    struct gecko_msg_system_external_signal_evt_t                evt_system_external_signal;
    struct gecko_msg_system_hardware_error_evt_t                 evt_system_hardware_error;
    struct gecko_msg_le_gap_open_cmd_t                           cmd_le_gap_open;
    struct gecko_msg_le_gap_open_rsp_t                           rsp_le_gap_open;
    struct gecko_msg_le_gap_set_mode_cmd_t                       cmd_le_gap_set_mode;
    struct gecko_msg_le_gap_set_mode_rsp_t                       rsp_le_gap_set_mode;
    struct gecko_msg_le_gap_discover_cmd_t                       cmd_le_gap_discover;
    struct gecko_msg_le_gap_discover_rsp_t                       rsp_le_gap_discover;
    struct gecko_msg_le_gap_end_procedure_rsp_t                  rsp_le_gap_end_procedure;
    struct gecko_msg_le_gap_set_adv_parameters_cmd_t             cmd_le_gap_set_adv_parameters;
    struct gecko_msg_le_gap_set_adv_parameters_rsp_t             rsp_le_gap_set_adv_parameters;
    struct gecko_msg_le_gap_set_conn_parameters_cmd_t            cmd_le_gap_set_conn_parameters;
    struct gecko_msg_le_gap_set_conn_parameters_rsp_t            rsp_le_gap_set_conn_parameters;
    struct gecko_msg_le_gap_set_scan_parameters_cmd_t            cmd_le_gap_set_scan_parameters;
    struct gecko_msg_le_gap_set_scan_parameters_rsp_t            rsp_le_gap_set_scan_parameters;
    struct gecko_msg_le_gap_set_adv_data_cmd_t                   cmd_le_gap_set_adv_data;
    struct gecko_msg_le_gap_set_adv_data_rsp_t                   rsp_le_gap_set_adv_data;
    struct gecko_msg_le_gap_set_adv_timeout_cmd_t                cmd_le_gap_set_adv_timeout;
    struct gecko_msg_le_gap_set_adv_timeout_rsp_t                rsp_le_gap_set_adv_timeout;
    struct gecko_msg_le_gap_set_phy_cmd_t                        cmd_le_gap_set_phy;
    struct gecko_msg_le_gap_set_phy_rsp_t                        rsp_le_gap_set_phy;
    struct gecko_msg_le_gap_bt5_set_mode_cmd_t                   cmd_le_gap_bt5_set_mode;
    struct gecko_msg_le_gap_bt5_set_mode_rsp_t                   rsp_le_gap_bt5_set_mode;
    struct gecko_msg_le_gap_bt5_set_adv_parameters_cmd_t         cmd_le_gap_bt5_set_adv_parameters;
    struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t         rsp_le_gap_bt5_set_adv_parameters;
    struct gecko_msg_le_gap_bt5_set_adv_data_cmd_t               cmd_le_gap_bt5_set_adv_data;
    struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t               rsp_le_gap_bt5_set_adv_data;
    struct gecko_msg_le_gap_set_privacy_mode_cmd_t               cmd_le_gap_set_privacy_mode;
    struct gecko_msg_le_gap_set_privacy_mode_rsp_t               rsp_le_gap_set_privacy_mode;
    struct gecko_msg_le_gap_scan_response_evt_t                  evt_le_gap_scan_response;
    struct gecko_msg_le_gap_scan_request_evt_t                   evt_le_gap_scan_request;
    struct gecko_msg_le_connection_set_parameters_cmd_t          cmd_le_connection_set_parameters;
    struct gecko_msg_le_connection_set_parameters_rsp_t          rsp_le_connection_set_parameters;
    struct gecko_msg_le_connection_get_rssi_cmd_t                cmd_le_connection_get_rssi;
    struct gecko_msg_le_connection_get_rssi_rsp_t                rsp_le_connection_get_rssi;
    struct gecko_msg_le_connection_disable_slave_latency_cmd_t   cmd_le_connection_disable_slave_latency;
    struct gecko_msg_le_connection_disable_slave_latency_rsp_t   rsp_le_connection_disable_slave_latency;
    struct gecko_msg_le_connection_set_phy_cmd_t                 cmd_le_connection_set_phy;
    struct gecko_msg_le_connection_set_phy_rsp_t                 rsp_le_connection_set_phy;
    struct gecko_msg_le_connection_opened_evt_t                  evt_le_connection_opened;
    struct gecko_msg_le_connection_closed_evt_t                  evt_le_connection_closed;
    struct gecko_msg_le_connection_parameters_evt_t              evt_le_connection_parameters;
    struct gecko_msg_le_connection_rssi_evt_t                    evt_le_connection_rssi;
    struct gecko_msg_le_connection_phy_status_evt_t              evt_le_connection_phy_status;
    struct gecko_msg_le_connection_bt5_opened_evt_t              evt_le_connection_bt5_opened;
    struct gecko_msg_gatt_set_max_mtu_cmd_t                      cmd_gatt_set_max_mtu;
    struct gecko_msg_gatt_set_max_mtu_rsp_t                      rsp_gatt_set_max_mtu;
    struct gecko_msg_gatt_discover_primary_services_cmd_t        cmd_gatt_discover_primary_services;
    struct gecko_msg_gatt_discover_primary_services_rsp_t        rsp_gatt_discover_primary_services;
    struct gecko_msg_gatt_discover_primary_services_by_uuid_cmd_t cmd_gatt_discover_primary_services_by_uuid;
    struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t rsp_gatt_discover_primary_services_by_uuid;
    struct gecko_msg_gatt_discover_characteristics_cmd_t         cmd_gatt_discover_characteristics;
    struct gecko_msg_gatt_discover_characteristics_rsp_t         rsp_gatt_discover_characteristics;
    struct gecko_msg_gatt_discover_characteristics_by_uuid_cmd_t cmd_gatt_discover_characteristics_by_uuid;
    struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t rsp_gatt_discover_characteristics_by_uuid;
    struct gecko_msg_gatt_set_characteristic_notification_cmd_t  cmd_gatt_set_characteristic_notification;
    struct gecko_msg_gatt_set_characteristic_notification_rsp_t  rsp_gatt_set_characteristic_notification;
    struct gecko_msg_gatt_discover_descriptors_cmd_t             cmd_gatt_discover_descriptors;
    struct gecko_msg_gatt_discover_descriptors_rsp_t             rsp_gatt_discover_descriptors;
    struct gecko_msg_gatt_read_characteristic_value_cmd_t        cmd_gatt_read_characteristic_value;
    struct gecko_msg_gatt_read_characteristic_value_rsp_t        rsp_gatt_read_characteristic_value;
    struct gecko_msg_gatt_read_characteristic_value_by_uuid_cmd_t cmd_gatt_read_characteristic_value_by_uuid;
    struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t rsp_gatt_read_characteristic_value_by_uuid;
    struct gecko_msg_gatt_write_characteristic_value_cmd_t       cmd_gatt_write_characteristic_value;
    struct gecko_msg_gatt_write_characteristic_value_rsp_t       rsp_gatt_write_characteristic_value;
    struct gecko_msg_gatt_write_characteristic_value_without_response_cmd_t cmd_gatt_write_characteristic_value_without_response;
    struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t rsp_gatt_write_characteristic_value_without_response;
    struct gecko_msg_gatt_prepare_characteristic_value_write_cmd_t cmd_gatt_prepare_characteristic_value_write;
    struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t rsp_gatt_prepare_characteristic_value_write;
    struct gecko_msg_gatt_execute_characteristic_value_write_cmd_t cmd_gatt_execute_characteristic_value_write;
    struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t rsp_gatt_execute_characteristic_value_write;
    struct gecko_msg_gatt_send_characteristic_confirmation_cmd_t cmd_gatt_send_characteristic_confirmation;
    struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t rsp_gatt_send_characteristic_confirmation;
    struct gecko_msg_gatt_read_descriptor_value_cmd_t            cmd_gatt_read_descriptor_value;
    struct gecko_msg_gatt_read_descriptor_value_rsp_t            rsp_gatt_read_descriptor_value;
    struct gecko_msg_gatt_write_descriptor_value_cmd_t           cmd_gatt_write_descriptor_value;
    struct gecko_msg_gatt_write_descriptor_value_rsp_t           rsp_gatt_write_descriptor_value;
    struct gecko_msg_gatt_find_included_services_cmd_t           cmd_gatt_find_included_services;
    struct gecko_msg_gatt_find_included_services_rsp_t           rsp_gatt_find_included_services;
    struct gecko_msg_gatt_read_multiple_characteristic_values_cmd_t cmd_gatt_read_multiple_characteristic_values;
    struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t rsp_gatt_read_multiple_characteristic_values;
    struct gecko_msg_gatt_read_characteristic_value_from_offset_cmd_t cmd_gatt_read_characteristic_value_from_offset;
    struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t rsp_gatt_read_characteristic_value_from_offset;
    struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_cmd_t cmd_gatt_prepare_characteristic_value_reliable_write;
    struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t rsp_gatt_prepare_characteristic_value_reliable_write;
    struct gecko_msg_gatt_mtu_exchanged_evt_t                    evt_gatt_mtu_exchanged;
    struct gecko_msg_gatt_service_evt_t                          evt_gatt_service;
    struct gecko_msg_gatt_characteristic_evt_t                   evt_gatt_characteristic;
    struct gecko_msg_gatt_descriptor_evt_t                       evt_gatt_descriptor;
    struct gecko_msg_gatt_characteristic_value_evt_t             evt_gatt_characteristic_value;
    struct gecko_msg_gatt_descriptor_value_evt_t                 evt_gatt_descriptor_value;
    struct gecko_msg_gatt_procedure_completed_evt_t              evt_gatt_procedure_completed;
    struct gecko_msg_gatt_server_read_attribute_value_cmd_t      cmd_gatt_server_read_attribute_value;
    struct gecko_msg_gatt_server_read_attribute_value_rsp_t      rsp_gatt_server_read_attribute_value;
    struct gecko_msg_gatt_server_read_attribute_type_cmd_t       cmd_gatt_server_read_attribute_type;
    struct gecko_msg_gatt_server_read_attribute_type_rsp_t       rsp_gatt_server_read_attribute_type;
    struct gecko_msg_gatt_server_write_attribute_value_cmd_t     cmd_gatt_server_write_attribute_value;
    struct gecko_msg_gatt_server_write_attribute_value_rsp_t     rsp_gatt_server_write_attribute_value;
    struct gecko_msg_gatt_server_send_user_read_response_cmd_t   cmd_gatt_server_send_user_read_response;
    struct gecko_msg_gatt_server_send_user_read_response_rsp_t   rsp_gatt_server_send_user_read_response;
    struct gecko_msg_gatt_server_send_user_write_response_cmd_t  cmd_gatt_server_send_user_write_response;
    struct gecko_msg_gatt_server_send_user_write_response_rsp_t  rsp_gatt_server_send_user_write_response;
    struct gecko_msg_gatt_server_send_characteristic_notification_cmd_t cmd_gatt_server_send_characteristic_notification;
    struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t rsp_gatt_server_send_characteristic_notification;
    struct gecko_msg_gatt_server_find_attribute_cmd_t            cmd_gatt_server_find_attribute;
    struct gecko_msg_gatt_server_find_attribute_rsp_t            rsp_gatt_server_find_attribute;
    struct gecko_msg_gatt_server_set_database_cmd_t              cmd_gatt_server_set_database;
    struct gecko_msg_gatt_server_set_database_rsp_t              rsp_gatt_server_set_database;
    struct gecko_msg_gatt_server_set_capabilities_cmd_t          cmd_gatt_server_set_capabilities;
    struct gecko_msg_gatt_server_set_capabilities_rsp_t          rsp_gatt_server_set_capabilities;
    struct gecko_msg_gatt_server_attribute_value_evt_t           evt_gatt_server_attribute_value;
    struct gecko_msg_gatt_server_user_read_request_evt_t         evt_gatt_server_user_read_request;
    struct gecko_msg_gatt_server_user_write_request_evt_t        evt_gatt_server_user_write_request;
    struct gecko_msg_gatt_server_characteristic_status_evt_t     evt_gatt_server_characteristic_status;
    struct gecko_msg_gatt_server_execute_write_completed_evt_t   evt_gatt_server_execute_write_completed;
    struct gecko_msg_endpoint_send_cmd_t                         cmd_endpoint_send;
    struct gecko_msg_endpoint_send_rsp_t                         rsp_endpoint_send;
    struct gecko_msg_endpoint_set_streaming_destination_cmd_t    cmd_endpoint_set_streaming_destination;
    struct gecko_msg_endpoint_set_streaming_destination_rsp_t    rsp_endpoint_set_streaming_destination;
    struct gecko_msg_endpoint_close_cmd_t                        cmd_endpoint_close;
    struct gecko_msg_endpoint_close_rsp_t                        rsp_endpoint_close;
    struct gecko_msg_endpoint_set_flags_cmd_t                    cmd_endpoint_set_flags;
    struct gecko_msg_endpoint_set_flags_rsp_t                    rsp_endpoint_set_flags;
    struct gecko_msg_endpoint_clr_flags_cmd_t                    cmd_endpoint_clr_flags;
    struct gecko_msg_endpoint_clr_flags_rsp_t                    rsp_endpoint_clr_flags;
    struct gecko_msg_endpoint_read_counters_cmd_t                cmd_endpoint_read_counters;
    struct gecko_msg_endpoint_read_counters_rsp_t                rsp_endpoint_read_counters;
    struct gecko_msg_endpoint_syntax_error_evt_t                 evt_endpoint_syntax_error;
    struct gecko_msg_endpoint_data_evt_t                         evt_endpoint_data;
    struct gecko_msg_endpoint_status_evt_t                       evt_endpoint_status;
    struct gecko_msg_hardware_set_soft_timer_cmd_t               cmd_hardware_set_soft_timer;
    struct gecko_msg_hardware_set_soft_timer_rsp_t               rsp_hardware_set_soft_timer;
    struct gecko_msg_hardware_get_time_rsp_t                     rsp_hardware_get_time;
    struct gecko_msg_hardware_set_lazy_soft_timer_cmd_t          cmd_hardware_set_lazy_soft_timer;
    struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t          rsp_hardware_set_lazy_soft_timer;
    struct gecko_msg_hardware_enable_dcdc_cmd_t                  cmd_hardware_enable_dcdc;
    struct gecko_msg_hardware_enable_dcdc_rsp_t                  rsp_hardware_enable_dcdc;
    struct gecko_msg_hardware_soft_timer_evt_t                   evt_hardware_soft_timer;
    struct gecko_msg_flash_ps_dump_rsp_t                         rsp_flash_ps_dump;
    struct gecko_msg_flash_ps_erase_all_rsp_t                    rsp_flash_ps_erase_all;
    struct gecko_msg_flash_ps_save_cmd_t                         cmd_flash_ps_save;
    struct gecko_msg_flash_ps_save_rsp_t                         rsp_flash_ps_save;
    struct gecko_msg_flash_ps_load_cmd_t                         cmd_flash_ps_load;
    struct gecko_msg_flash_ps_load_rsp_t                         rsp_flash_ps_load;
    struct gecko_msg_flash_ps_erase_cmd_t                        cmd_flash_ps_erase;
    struct gecko_msg_flash_ps_erase_rsp_t                        rsp_flash_ps_erase;
    struct gecko_msg_flash_ps_key_evt_t                          evt_flash_ps_key;
    struct gecko_msg_test_dtm_tx_cmd_t                           cmd_test_dtm_tx;
    struct gecko_msg_test_dtm_tx_rsp_t                           rsp_test_dtm_tx;
    struct gecko_msg_test_dtm_rx_cmd_t                           cmd_test_dtm_rx;
    struct gecko_msg_test_dtm_rx_rsp_t                           rsp_test_dtm_rx;
    struct gecko_msg_test_dtm_end_rsp_t                          rsp_test_dtm_end;
    struct gecko_msg_test_debug_command_cmd_t                    cmd_test_debug_command;
    struct gecko_msg_test_debug_command_rsp_t                    rsp_test_debug_command;
    struct gecko_msg_test_debug_counter_cmd_t                    cmd_test_debug_counter;
    struct gecko_msg_test_debug_counter_rsp_t                    rsp_test_debug_counter;
    struct gecko_msg_test_dtm_completed_evt_t                    evt_test_dtm_completed;
    struct gecko_msg_test_hcidump_evt_t                          evt_test_hcidump;
    struct gecko_msg_sm_set_bondable_mode_cmd_t                  cmd_sm_set_bondable_mode;
    struct gecko_msg_sm_set_bondable_mode_rsp_t                  rsp_sm_set_bondable_mode;
    struct gecko_msg_sm_configure_cmd_t                          cmd_sm_configure;
    struct gecko_msg_sm_configure_rsp_t                          rsp_sm_configure;
    struct gecko_msg_sm_store_bonding_configuration_cmd_t        cmd_sm_store_bonding_configuration;
    struct gecko_msg_sm_store_bonding_configuration_rsp_t        rsp_sm_store_bonding_configuration;
    struct gecko_msg_sm_increase_security_cmd_t                  cmd_sm_increase_security;
    struct gecko_msg_sm_increase_security_rsp_t                  rsp_sm_increase_security;
    struct gecko_msg_sm_delete_bonding_cmd_t                     cmd_sm_delete_bonding;
    struct gecko_msg_sm_delete_bonding_rsp_t                     rsp_sm_delete_bonding;
    struct gecko_msg_sm_delete_bondings_rsp_t                    rsp_sm_delete_bondings;
    struct gecko_msg_sm_enter_passkey_cmd_t                      cmd_sm_enter_passkey;
    struct gecko_msg_sm_enter_passkey_rsp_t                      rsp_sm_enter_passkey;
    struct gecko_msg_sm_passkey_confirm_cmd_t                    cmd_sm_passkey_confirm;
    struct gecko_msg_sm_passkey_confirm_rsp_t                    rsp_sm_passkey_confirm;
    struct gecko_msg_sm_set_oob_data_cmd_t                       cmd_sm_set_oob_data;
    struct gecko_msg_sm_set_oob_data_rsp_t                       rsp_sm_set_oob_data;
    struct gecko_msg_sm_list_all_bondings_rsp_t                  rsp_sm_list_all_bondings;
    struct gecko_msg_sm_bonding_confirm_cmd_t                    cmd_sm_bonding_confirm;
    struct gecko_msg_sm_bonding_confirm_rsp_t                    rsp_sm_bonding_confirm;
    struct gecko_msg_sm_set_debug_mode_rsp_t                     rsp_sm_set_debug_mode;
    struct gecko_msg_sm_set_passkey_cmd_t                        cmd_sm_set_passkey;
    struct gecko_msg_sm_set_passkey_rsp_t                        rsp_sm_set_passkey;
    struct gecko_msg_sm_use_sc_oob_cmd_t                         cmd_sm_use_sc_oob;
    struct gecko_msg_sm_use_sc_oob_rsp_t                         rsp_sm_use_sc_oob;
    struct gecko_msg_sm_set_sc_remote_oob_data_cmd_t             cmd_sm_set_sc_remote_oob_data;
    struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t             rsp_sm_set_sc_remote_oob_data;
    struct gecko_msg_sm_passkey_display_evt_t                    evt_sm_passkey_display;
    struct gecko_msg_sm_passkey_request_evt_t                    evt_sm_passkey_request;
    struct gecko_msg_sm_confirm_passkey_evt_t                    evt_sm_confirm_passkey;
    struct gecko_msg_sm_bonded_evt_t                             evt_sm_bonded;
    struct gecko_msg_sm_bonding_failed_evt_t                     evt_sm_bonding_failed;
    struct gecko_msg_sm_list_bonding_entry_evt_t                 evt_sm_list_bonding_entry;
    struct gecko_msg_sm_confirm_bonding_evt_t                    evt_sm_confirm_bonding;
    struct gecko_msg_homekit_configure_cmd_t                     cmd_homekit_configure;
    struct gecko_msg_homekit_configure_rsp_t                     rsp_homekit_configure;
    struct gecko_msg_homekit_advertise_cmd_t                     cmd_homekit_advertise;
    struct gecko_msg_homekit_advertise_rsp_t                     rsp_homekit_advertise;
    struct gecko_msg_homekit_delete_pairings_rsp_t               rsp_homekit_delete_pairings;
    struct gecko_msg_homekit_check_authcp_rsp_t                  rsp_homekit_check_authcp;
    struct gecko_msg_homekit_get_pairing_id_cmd_t                cmd_homekit_get_pairing_id;
    struct gecko_msg_homekit_get_pairing_id_rsp_t                rsp_homekit_get_pairing_id;
    struct gecko_msg_homekit_send_write_response_cmd_t           cmd_homekit_send_write_response;
    struct gecko_msg_homekit_send_write_response_rsp_t           rsp_homekit_send_write_response;
    struct gecko_msg_homekit_send_read_response_cmd_t            cmd_homekit_send_read_response;
    struct gecko_msg_homekit_send_read_response_rsp_t            rsp_homekit_send_read_response;
    struct gecko_msg_homekit_gsn_action_cmd_t                    cmd_homekit_gsn_action;
    struct gecko_msg_homekit_gsn_action_rsp_t                    rsp_homekit_gsn_action;
    struct gecko_msg_homekit_event_notification_cmd_t            cmd_homekit_event_notification;
    struct gecko_msg_homekit_event_notification_rsp_t            rsp_homekit_event_notification;
    struct gecko_msg_homekit_setupcode_display_evt_t             evt_homekit_setupcode_display;
    struct gecko_msg_homekit_paired_evt_t                        evt_homekit_paired;
    struct gecko_msg_homekit_pair_verified_evt_t                 evt_homekit_pair_verified;
    struct gecko_msg_homekit_connection_opened_evt_t             evt_homekit_connection_opened;
    struct gecko_msg_homekit_connection_closed_evt_t             evt_homekit_connection_closed;
    struct gecko_msg_homekit_identify_evt_t                      evt_homekit_identify;
    struct gecko_msg_homekit_write_request_evt_t                 evt_homekit_write_request;
    struct gecko_msg_homekit_read_request_evt_t                  evt_homekit_read_request;
    struct gecko_msg_homekit_error_evt_t                         evt_homekit_error;
    struct gecko_msg_homekit_pairing_removed_evt_t               evt_homekit_pairing_removed;
    struct gecko_msg_user_message_to_target_cmd_t                cmd_user_message_to_target;
    struct gecko_msg_user_message_to_target_rsp_t                rsp_user_message_to_target;
    struct gecko_msg_user_message_to_host_evt_t                  evt_user_message_to_host;

    uint8 *payload;
})data;
};

/**
 * Initialize BGAPI class dfu. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_dfu_init();

/**
 * Initialize BGAPI class system. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_system_init();

/**
 * Initialize BGAPI class le_gap. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_le_gap_init();

/**
 * Initialize BGAPI class le_connection. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_le_connection_init();

/**
 * Initialize BGAPI class gatt. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_gatt_init();

/**
 * Initialize BGAPI class gatt_server. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_gatt_server_init();

/**
 * Initialize BGAPI class endpoint. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_endpoint_init();

/**
 * Initialize BGAPI class hardware. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_hardware_init();

/**
 * Initialize BGAPI class flash. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_flash_init();

/**
 * Initialize BGAPI class test. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_test_init();

/**
 * Initialize BGAPI class sm. This initializer function must be called if any command
 * from this class is going to be used.
 */
void gecko_bgapi_class_sm_init();


/**
 * Initialize stack and all BGAPI classes.
 * This is a convenience method for getting the stack and all BGAPI classes usable by the application.
 * If application wants to initialize only a subset of BGAPI classes, this function should not be called. Instead,
 * first call gecko_stack_init() to initialize stack, and then call individual BGAPI class initializers.
 *
 * @param config if set as NULL uses default values for all configuration parameters
 */
static inline void gecko_init(const gecko_configuration_t *config)
{
    gecko_stack_init(config);


    gecko_bgapi_class_dfu_init();
    gecko_bgapi_class_system_init();
    gecko_bgapi_class_le_gap_init();
    gecko_bgapi_class_le_connection_init();
    gecko_bgapi_class_gatt_init();
    gecko_bgapi_class_gatt_server_init();
    gecko_bgapi_class_endpoint_init();
    gecko_bgapi_class_hardware_init();
    gecko_bgapi_class_flash_init();
    gecko_bgapi_class_test_init();
    gecko_bgapi_class_sm_init();
}



extern struct gecko_cmd_packet*  gecko_cmd_msg;
extern struct gecko_cmd_packet*  gecko_rsp_msg;


void gecko_handle_command(uint32_t,void*);
void gecko_handle_command_noresponse(uint32_t,void*);
/** This command can be used to reset the system. This command does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) after re-boot.  **/

static inline void* gecko_cmd_dfu_reset(uint8 dfu)
{
    gecko_cmd_msg->data.cmd_dfu_reset.dfu=dfu;
    gecko_cmd_msg->header=gecko_cmd_dfu_reset_id+((1)<<8);
	gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return 0;
}

/** After re-booting the local device into DFU mode, this command can be used to define the starting address on the flash to where the new firmware will be written in. **/

static inline struct gecko_msg_dfu_flash_set_address_rsp_t* gecko_cmd_dfu_flash_set_address(uint32 address)
{
    gecko_cmd_msg->data.cmd_dfu_flash_set_address.address=address;
    gecko_cmd_msg->header=gecko_cmd_dfu_flash_set_address_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_dfu_flash_set_address;
}

/** This command can be used to upload the whole firmware image file into the Bluetooth device. The passed data length must be a multiple of 4 bytes. As the BGAPI command payload size is limited, multiple commands need to be issued one after the other until the whole .bin firmware image file is uploaded to the device. The next address of the flash sector in memory to write to is automatically updated by the bootloader after each individual command. **/

static inline struct gecko_msg_dfu_flash_upload_rsp_t* gecko_cmd_dfu_flash_upload(uint8 data_len, const uint8* data_data)
{
    if ((uint16_t)data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_dfu_flash_upload.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
    }

    gecko_cmd_msg->data.cmd_dfu_flash_upload.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_dfu_flash_upload.data.data,data_data,data_len);
    gecko_cmd_msg->header=gecko_cmd_dfu_flash_upload_id+((1+data_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_dfu_flash_upload;
}

/** This command can be used to tell to the device that the DFU file has been fully uploaded. To return the device back to normal mode the command {a href="#cmd_dfu_reset"}DFU Reset {/a} must be issued next. **/

static inline struct gecko_msg_dfu_flash_upload_finish_rsp_t* gecko_cmd_dfu_flash_upload_finish()
{
    gecko_cmd_msg->header=gecko_cmd_dfu_flash_upload_finish_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_dfu_flash_upload_finish;
}

/** This command does not trigger any event but the response to the command is used to verify that communication between the host and the device is working. **/

static inline struct gecko_msg_system_hello_rsp_t* gecko_cmd_system_hello()
{
    gecko_cmd_msg->header=gecko_cmd_system_hello_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_hello;
}

/** 
            This command can be used to reset the system. It does not have a response, but it triggers one of the boot events (normal reset or boot to DFU mode) depending on the selected boot mode. **/

static inline void* gecko_cmd_system_reset(uint8 dfu)
{
    gecko_cmd_msg->data.cmd_system_reset.dfu=dfu;
    gecko_cmd_msg->header=gecko_cmd_system_reset_id+((1)<<8);
	gecko_handle_command_noresponse(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return 0;
}

/** This command can be used to read the Bluetooth public address used by the device. **/

static inline struct gecko_msg_system_get_bt_address_rsp_t* gecko_cmd_system_get_bt_address()
{
    gecko_cmd_msg->header=gecko_cmd_system_get_bt_address_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_get_bt_address;
}

/** 
                This command can be used to set the Bluetooth public address used by the device. A valid address set with this command overrides the default Bluetooth public address programmed at production, and it will be effective in the next system reboot. The stack treats 00:00:00:00:00:00 and ff:ff:ff:ff:ff:ff as invalid addresses. Thus passing one of them into this command will cause the stack to use the default address in the next system reboot.
             **/

static inline struct gecko_msg_system_set_bt_address_rsp_t* gecko_cmd_system_set_bt_address(bd_addr address)
{
    memcpy(&gecko_cmd_msg->data.cmd_system_set_bt_address.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->header=gecko_cmd_system_set_bt_address_id+((6)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_set_bt_address;
}

/** 
                This command can be used to set the TX power. It returns the power that was set. If the GATT server contains a Tx Power service, the Tx Power Level attribute of the service will be updated accordingly.

                {p}{b}NOTE:{/b} This command should not be used while advertising, scanning or during connection.{/p}
             **/

static inline struct gecko_msg_system_set_tx_power_rsp_t* gecko_cmd_system_set_tx_power(int16 power)
{
    gecko_cmd_msg->data.cmd_system_set_tx_power.power=power;
    gecko_cmd_msg->header=gecko_cmd_system_set_tx_power_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_set_tx_power;
}

/** 
                This command can be used to get random data up to 16 bytes.
             **/

static inline struct gecko_msg_system_get_random_data_rsp_t* gecko_cmd_system_get_random_data(uint8 length)
{
    gecko_cmd_msg->data.cmd_system_get_random_data.length=length;
    gecko_cmd_msg->header=gecko_cmd_system_get_random_data_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_get_random_data;
}

/** 
                This command forces radio to idle state and allows device to sleep. Advertising, scanning, connections and software timers are halted by this commands. Halted operations are resumed by calling this command with parameter 0. Connections stay alive if system is resumed before connection supervision timeout.
                {p}{b}NOTE:{/b}Software timer is also halted. Hardware interrupts are the only way to wake up from energy mode 2 when system is halted.{/p}
             **/

static inline struct gecko_msg_system_halt_rsp_t* gecko_cmd_system_halt(uint8 halt)
{
    gecko_cmd_msg->data.cmd_system_halt.halt=halt;
    gecko_cmd_msg->header=gecko_cmd_system_halt_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_halt;
}

/** This command can be used to set the device name. Currently it is possible to set the name which will be used during the OTA update. The name will be stored in persistent storage.
            If the OTA device name is also set in gecko configuration, the name stored in persistent storage is overwritten with the name in gecko configuration during device boot. **/

static inline struct gecko_msg_system_set_device_name_rsp_t* gecko_cmd_system_set_device_name(uint8 type,uint8 name_len, const uint8* name_data)
{
    if ((uint16_t)name_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_system_set_device_name.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_system_set_device_name;
    }

    gecko_cmd_msg->data.cmd_system_set_device_name.type=type;
    gecko_cmd_msg->data.cmd_system_set_device_name.name.len=name_len;
    memcpy(gecko_cmd_msg->data.cmd_system_set_device_name.name.data,name_data,name_len);
    gecko_cmd_msg->header=gecko_cmd_system_set_device_name_id+((2+name_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_system_set_device_name;
}

/** 
                {p}This command can be used to connect an advertising device.
                Scanning parameters can be configured with the
                le_gap_set_scan_parameters command before issuing this command.
                The Bluetooth stack will enter a state where it continuously
                scans for the connectable advertisement packets from the remote
                device which matches the Bluetooth address given as a
                parameter. Upon receiving the advertisement packet, the module
                will send a connection request packet to the target device to
                initiate a Bluetooth connection. To cancel an ongoing
                connection process use the endpoint_close command with the
                handle received in the le_gap_open response.{/p}

                {p}A connection is opened in no-security mode. If the GATT
                client needs to read or write the attributes on GATT server
                requiring encryption or authentication, it must first encrypt
                the connection using an appropriate authentication method.{/p}

                {p}This command fails with "Connection Limit Exceeded" error if 
                the number of connections attempted to be opened exceeds the
                max_connections value configured.{/p}

                {p}Later calls of this command have to wait for the ongoing command
                 to complete. A received event 
                 {a href="#evt_le_connection_opened"}le_connection_opened{/a}
                 indicates connection opened successfully and a received event
                {a href="#evt_le_connection_closed"}le_connection_closed{/a} 
                indicates connection failures have occurred.
             **/

static inline struct gecko_msg_le_gap_open_rsp_t* gecko_cmd_le_gap_open(bd_addr address,uint8 address_type)
{
    memcpy(&gecko_cmd_msg->data.cmd_le_gap_open.address,&address,sizeof(bd_addr));
    gecko_cmd_msg->data.cmd_le_gap_open.address_type=address_type;
    gecko_cmd_msg->header=gecko_cmd_le_gap_open_id+((7)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_open;
}

/** This command can be used to configure the current Bluetooth LE GAP Connectable and Discoverable modes. It can be used to enable advertisements and/or allow incoming connections. To exit from this mode (to stop advertising and/or disallow incoming connections), issue this command with the Not Discoverable / Not Connectable parameter values.
            Command will take effect immediately. If currently set parameters can't be used with new mode then an error will be returned.
            {p}If advertisement will be enabled in user_data mode, {a href="#cmd_le_gap_set_adv_data"}le_gap_set_adv_data{/a} should be used to set advertisement and scan response data before issuing this command. When the advertisement is enabled in other modes than user_data, the advertisement and scan response data is generated by the stack using the following procedure:{/p}
            {p}
                {ol}
                    {li}Add a Flags field to advertisement data.{/li}
                    {li}Add a TX power level field to advertisement data if TX power service exists in the local GATT database.{/li}
                    {li}Add a Slave Connection Interval Range field to advertisement data if the GAP peripheral preferred connection parameters characteristic exists in the local GATT database.{/li}
                    {li}Add a list of 16-bit Service UUIDs to advertisement data if there are one or more 16-bit service UUIDs to advertise. The list is complete if all advertised 16-bit UUIDs are in advertisement data; otherwise the list is incomplete.{/li}
                    {li}Add a list of 128-bit service UUIDs to advertisement data if there are one or more 128-bit service UUIDs to advertise and there is still free space for this field. The list is complete if all advertised 128-bit UUIDs are in advertisement data; otherwise the list is incomplete. Note that an advertisement data packet can contain at most one 128-bit service UUID.{/li}
                    {li}Try to add the full local name to advertisement data if device is not in privacy mode. In case the full local name does not fit into the remaining free space, the advertised name is a shortened version by cutting off the end if the free space has at least 6 bytes; Otherwise, the local name is added to scan response data.{/li}
                {/ol}
            {/p}
            {p}This command fails with "Connection Limit Exceeded" error if the number of connections has reached the max_connections value configured.{/p}
             **/

static inline struct gecko_msg_le_gap_set_mode_rsp_t* gecko_cmd_le_gap_set_mode(uint8 discover,uint8 connect)
{
    gecko_cmd_msg->data.cmd_le_gap_set_mode.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_set_mode.connect=connect;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_mode_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_mode;
}

/** This command can be used to start the GAP discovery procedure to scan for advertising devices, that is to perform a device discovery. Scanning parameters 
            can be configured with the {a href="#cmd_le_gap_set_scan_parameters"}le_gap_set_scan_parameters{/a} command before issuing this command. To cancel an ongoing 
            discovery process use the {a href="#cmd_le_gap_end_procedure"}le_gap_end_procedure{/a} command. **/

static inline struct gecko_msg_le_gap_discover_rsp_t* gecko_cmd_le_gap_discover(uint8 mode)
{
    gecko_cmd_msg->data.cmd_le_gap_discover.mode=mode;
    gecko_cmd_msg->header=gecko_cmd_le_gap_discover_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_discover;
}

/** This command can be used to end a current GAP procedure. **/

static inline struct gecko_msg_le_gap_end_procedure_rsp_t* gecko_cmd_le_gap_end_procedure()
{
    gecko_cmd_msg->header=gecko_cmd_le_gap_end_procedure_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_end_procedure;
}

/** This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to set Bluetooth LE advertisement parameters. First, use this command to set advertisement parameters, and then use command {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to start or restart advertisement. If parameters can't be used with currently active mode an error will be returned. **/

static inline struct gecko_msg_le_gap_set_adv_parameters_rsp_t* gecko_cmd_le_gap_set_adv_parameters(uint16 interval_min,uint16 interval_max,uint8 channel_map)
{
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_parameters.channel_map=channel_map;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_parameters_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_parameters;
}

/** This command can be used to set the default Bluetooth LE connection parameters. The configured values are valid for all subsequent connections that will 
            be established. For changing the parameters of an already established connection use the command {a href="#cmd_le_connection_set_parameters"}le_connection_set_parameters{/a}. **/

static inline struct gecko_msg_le_gap_set_conn_parameters_rsp_t* gecko_cmd_le_gap_set_conn_parameters(uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout)
{
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_gap_set_conn_parameters.timeout=timeout;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_conn_parameters_id+((8)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_conn_parameters;
}

/** This command can be used to set Bluetooth LE scan parameters. If the device is currently scanning for advertising devices new parameters will take effect when the scanning is restarted. **/

static inline struct gecko_msg_le_gap_set_scan_parameters_rsp_t* gecko_cmd_le_gap_set_scan_parameters(uint16 scan_interval,uint16 scan_window,uint8 active)
{
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_interval=scan_interval;
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.scan_window=scan_window;
    gecko_cmd_msg->data.cmd_le_gap_set_scan_parameters.active=active;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_scan_parameters_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_scan_parameters;
}

/** This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to advertise user defined data. First use this command to set the data in advertisement packets and/or in the scan response packets, and then use command {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to configure this device to be discoverable in user_data mode. 
                {p}Note that the user defined data may be overwritten by the system when this device is later configured to other discoverable mode than user_data. It is recommended to set both the advertisement data and scan response data at the same time.{/p}
                {p}If advertisement mode is currently active, then new advertisement data will be used immediately.{/p} **/

static inline struct gecko_msg_le_gap_set_adv_data_rsp_t* gecko_cmd_le_gap_set_adv_data(uint8 scan_rsp,uint8 adv_data_len, const uint8* adv_data_data)
{
    if ((uint16_t)adv_data_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_le_gap_set_adv_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
    }

    gecko_cmd_msg->data.cmd_le_gap_set_adv_data.scan_rsp=scan_rsp;
    gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.len=adv_data_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_data_id+((2+adv_data_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_data;
}

/** This command can be used together with {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} to set the number of advertisements before stopping. **/

static inline struct gecko_msg_le_gap_set_adv_timeout_rsp_t* gecko_cmd_le_gap_set_adv_timeout(uint8 intervals)
{
    gecko_cmd_msg->data.cmd_le_gap_set_adv_timeout.intervals=intervals;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_adv_timeout_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_adv_timeout;
}

/**  **/

static inline struct gecko_msg_le_gap_set_phy_rsp_t* gecko_cmd_le_gap_set_phy(uint8 phy)
{
    gecko_cmd_msg->data.cmd_le_gap_set_phy.phy=phy;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_phy_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_phy;
}

/** This command is used to set one advertisement sets mode, this works the same way as {a href="#cmd_le_gap_set_mode"}le_gap_set_mode{/a} except has extra parameters to support Bluetooth 5 advertisement set and features **/

static inline struct gecko_msg_le_gap_bt5_set_mode_rsp_t* gecko_cmd_le_gap_bt5_set_mode(uint8 handle,uint8 discover,uint8 connect,uint16 maxevents,uint8 address_type)
{
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.discover=discover;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.connect=connect;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.maxevents=maxevents;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_mode.address_type=address_type;
    gecko_cmd_msg->header=gecko_cmd_le_gap_bt5_set_mode_id+((6)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_mode;
}

/** This command can be used to set Bluetooth 5 LE advertisement parameters.
            This is same as {a href="#cmd_le_gap_set_adv_parameters"}le_gap_set_adv_parameters{/a} except this supports Bluetooth 5 extended features. **/

static inline struct gecko_msg_le_gap_bt5_set_adv_parameters_rsp_t* gecko_cmd_le_gap_bt5_set_adv_parameters(uint8 handle,uint16 interval_min,uint16 interval_max,uint8 channel_map,uint8 report_scan)
{
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.channel_map=channel_map;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_parameters.report_scan=report_scan;
    gecko_cmd_msg->header=gecko_cmd_le_gap_bt5_set_adv_parameters_id+((7)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_parameters;
}

/** Same as {a href="#cmd_le_gap_set_adv_data"}le_gap_set_adv_data{/a} except this command supports Bluetooth 5 advertisement sets **/

static inline struct gecko_msg_le_gap_bt5_set_adv_data_rsp_t* gecko_cmd_le_gap_bt5_set_adv_data(uint8 handle,uint8 scan_rsp,uint8 adv_data_len, const uint8* adv_data_data)
{
    if ((uint16_t)adv_data_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data;
    }

    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.handle=handle;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.scan_rsp=scan_rsp;
    gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.adv_data.len=adv_data_len;
    memcpy(gecko_cmd_msg->data.cmd_le_gap_bt5_set_adv_data.adv_data.data,adv_data_data,adv_data_len);
    gecko_cmd_msg->header=gecko_cmd_le_gap_bt5_set_adv_data_id+((3+adv_data_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_bt5_set_adv_data;
}

/** 
            This command can be used to enable or disable privacy feature on all GAP roles. The new privacy mode will take effect for advertising on the next advertising enabling, for scanning on the next scan enabling, and for initiating on the next open connection command. When privacy is enabled and the device is advertising or scanning, the stack will maintain a periodic timer with the specified time interval as timeout value. At each timeout the stack will generate a new private resolvable address and use it in advertising data packets and scanning requests.
            {p}By default, privacy feature is disabled.{/p}
             **/

static inline struct gecko_msg_le_gap_set_privacy_mode_rsp_t* gecko_cmd_le_gap_set_privacy_mode(uint8 privacy,uint8 interval)
{
    gecko_cmd_msg->data.cmd_le_gap_set_privacy_mode.privacy=privacy;
    gecko_cmd_msg->data.cmd_le_gap_set_privacy_mode.interval=interval;
    gecko_cmd_msg->header=gecko_cmd_le_gap_set_privacy_mode_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_gap_set_privacy_mode;
}

/** This command can be used to request a change in the connection parameters of a Bluetooth LE connection. **/

static inline struct gecko_msg_le_connection_set_parameters_rsp_t* gecko_cmd_le_connection_set_parameters(uint8 connection,uint16 min_interval,uint16 max_interval,uint16 latency,uint16 timeout)
{
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.min_interval=min_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.max_interval=max_interval;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.latency=latency;
    gecko_cmd_msg->data.cmd_le_connection_set_parameters.timeout=timeout;
    gecko_cmd_msg->header=gecko_cmd_le_connection_set_parameters_id+((9)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_connection_set_parameters;
}

/** This command can be used to get the latest RSSI value of a BLE connection. **/

static inline struct gecko_msg_le_connection_get_rssi_rsp_t* gecko_cmd_le_connection_get_rssi(uint8 connection)
{
    gecko_cmd_msg->data.cmd_le_connection_get_rssi.connection=connection;
    gecko_cmd_msg->header=gecko_cmd_le_connection_get_rssi_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_connection_get_rssi;
}

/** This command temporarily enables or disables slave latency. Used only when Bluetooth device is in slave role. **/

static inline struct gecko_msg_le_connection_disable_slave_latency_rsp_t* gecko_cmd_le_connection_disable_slave_latency(uint8 connection,uint8 disable)
{
    gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_disable_slave_latency.disable=disable;
    gecko_cmd_msg->header=gecko_cmd_le_connection_disable_slave_latency_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_connection_disable_slave_latency;
}

/** This command can be used to set preferred PHYs for connection. Preferred PHYs are connection specific. Event {a href="#evt_le_connection_phy_status"}le_connection_phy_status{/a} is received when PHY update procedure has been completed. Other than preferred PHY can also be set if remote device does not accept any of the preferred PHYs. {p}{b}NOTE:{/b} Minimum connection interval for 125 kbit and 500 kbit phys is currently 32 (40 ms). Coded PHY is not used if connection interval is under that limit.{/p}{p}{b}NOTE:{/b} 2 Mbit and Coded PHYs are not supported by all devices.{/p} **/

static inline struct gecko_msg_le_connection_set_phy_rsp_t* gecko_cmd_le_connection_set_phy(uint8 connection,uint8 phy)
{
    gecko_cmd_msg->data.cmd_le_connection_set_phy.connection=connection;
    gecko_cmd_msg->data.cmd_le_connection_set_phy.phy=phy;
    gecko_cmd_msg->header=gecko_cmd_le_connection_set_phy_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_le_connection_set_phy;
}

/** This command can be used to set the maximum size of ATT Message Transfer Units (MTU). If the given value is too large according to the maximum BGAPI payload size, the system will select the maximal possible value as the maximum ATT_MTU. If maximum ATT_MTU is larger than 23, MTU is exchanged automatically after Bluetooth LE connection has been established. **/

static inline struct gecko_msg_gatt_set_max_mtu_rsp_t* gecko_cmd_gatt_set_max_mtu(uint16 max_mtu)
{
    gecko_cmd_msg->data.cmd_gatt_set_max_mtu.max_mtu=max_mtu;
    gecko_cmd_msg->header=gecko_cmd_gatt_set_max_mtu_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_set_max_mtu;
}

/** This command can be used to discover all the primary services of a remote GATT database. This command generates a unique gatt_service event for 
            every discovered primary service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure 
            has successfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_primary_services_rsp_t* gecko_cmd_gatt_discover_primary_services(uint8 connection)
{
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services.connection=connection;
    gecko_cmd_msg->header=gecko_cmd_gatt_discover_primary_services_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services;
}

/** This command can be used to discover primary services with the specified UUID in a remote GATT database. This command generates unique gatt_service event for every discovered primary service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_primary_services_by_uuid_rsp_t* gecko_cmd_gatt_discover_primary_services_by_uuid(uint8 connection,uint8 uuid_len, const uint8* uuid_data)
{
    if ((uint16_t)uuid_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
    }

    gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_discover_primary_services_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_discover_primary_services_by_uuid_id+((2+uuid_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_discover_primary_services_by_uuid;
}

/** This command can be used to discover all characteristics of the defined GATT service from a remote GATT database. This command generates a unique gatt_characteristic event for every discovered characteristic. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_characteristics_rsp_t* gecko_cmd_gatt_discover_characteristics(uint8 connection,uint32 service)
{
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics.service=service;
    gecko_cmd_msg->header=gecko_cmd_gatt_discover_characteristics_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics;
}

/** This command can be used to discover all the characteristics of the specified GATT service in a remote GATT database having the specified UUID. This command
generates a unique gatt_characteristic event for every discovered
characteristic having the specified UUID. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that
this GATT procedure has successfully completed or failed with error.
             **/

static inline struct gecko_msg_gatt_discover_characteristics_by_uuid_rsp_t* gecko_cmd_gatt_discover_characteristics_by_uuid(uint8 connection,uint32 service,uint8 uuid_len, const uint8* uuid_data)
{
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
    }

    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.service=service;
    gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_discover_characteristics_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_discover_characteristics_by_uuid_id+((6+uuid_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_discover_characteristics_by_uuid;
}

/** This command can be used to enable or disable the notifications and indications being sent from a remote GATT server. This procedure discovers a 
            characteristic client configuration descriptor and writes the related configuration flags to a remote GATT database. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event
            indicates that this GATT procedure has successfully completed or that is has failed with an error. **/

static inline struct gecko_msg_gatt_set_characteristic_notification_rsp_t* gecko_cmd_gatt_set_characteristic_notification(uint8 connection,uint16 characteristic,uint8 flags)
{
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_set_characteristic_notification.flags=flags;
    gecko_cmd_msg->header=gecko_cmd_gatt_set_characteristic_notification_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_set_characteristic_notification;
}

/** This command can be used to discover all the descriptors of the specified remote GATT characteristics in a remote GATT database. This command generates a unique gatt_descriptor event for every discovered descriptor. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. **/

static inline struct gecko_msg_gatt_discover_descriptors_rsp_t* gecko_cmd_gatt_discover_descriptors(uint8 connection,uint16 characteristic)
{
    gecko_cmd_msg->data.cmd_gatt_discover_descriptors.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_discover_descriptors.characteristic=characteristic;
    gecko_cmd_msg->header=gecko_cmd_gatt_discover_descriptors_id+((3)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_discover_descriptors;
}

/** This command can be used to read the value of a characteristic from a remote GATT database. 
            A single {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} event is generated if the 
            characteristic value fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} events are generated because the firmware will automatically use the "read long" 
            GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates
            that all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_characteristic_value_rsp_t* gecko_cmd_gatt_read_characteristic_value(uint8 connection,uint16 characteristic)
{
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value.characteristic=characteristic;
    gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_id+((3)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value;
}

/** This command can be used to read the characteristic value of a service from a remote GATT database
            by giving the UUID of the characteristic and the handle of the service containing this characteristic. A single
            {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} event is generated if the characteristic
            value fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} events are generated because the firmware will automatically use the "read long" GATT procedure. 
            A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_characteristic_value_by_uuid_rsp_t* gecko_cmd_gatt_read_characteristic_value_by_uuid(uint8 connection,uint32 service,uint8 uuid_len, const uint8* uuid_data)
{
    if ((uint16_t)uuid_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
    }

    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.service=service;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.len=uuid_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_by_uuid.uuid.data,uuid_data,uuid_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_by_uuid_id+((6+uuid_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_by_uuid;
}

/** This command can be used to write the value of a characteristic in a remote GATT database. If the given value does not fit in one ATT PDU, "write long" GATT procedure is used automatically. Received 
            {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all data has been written successfully or that an error response 
            has been received. **/

static inline struct gecko_msg_gatt_write_characteristic_value_rsp_t* gecko_cmd_gatt_write_characteristic_value(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_characteristic_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
    }

    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_write_characteristic_value_id+((4+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value;
}

/** This command can be used to write the value of a characteristic in a
            remote GATT server. This command does not generate any event. All failures on the server are ignored silently. 
            For example, if an error is generated in the remote GATT server and the given value is not written into database no error message will be reported to the local 
            GATT client. Note that this command cannot be used to write long values. At most ATT_MTU - 3 amount of data can be sent once. **/

static inline struct gecko_msg_gatt_write_characteristic_value_without_response_rsp_t* gecko_cmd_gatt_write_characteristic_value_without_response(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
    }

    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_characteristic_value_without_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_write_characteristic_value_without_response_id+((4+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_write_characteristic_value_without_response;
}

/** {p}This command can be used to add a characteristic value to the write queue of a remote GATT server. 
            This command can be used in cases where very long attributes need to be written, or a set of values needs to be written atomically. At most ATT_MTU - 5 amount of data can be sent once. Writes are executed or cancelled with the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.
            Whether the writes succeeded or not are indicated in the response of the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.{/p}
            {p}In all cases where the amount of data to transfer fits into the BGAPI payload the command 
            {a href="#cmd_gatt_write_characteristic_value"}gatt_write_characteristic_value{/a} is recommended for writing long values since it transparently 
            performs the prepare_write and execute_write commands.{/p}
             **/

static inline struct gecko_msg_gatt_prepare_characteristic_value_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
    }

    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_write.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_prepare_characteristic_value_write_id+((6+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_write;
}

/** This command can be used to commit or cancel previously queued writes to a long characteristic of a remote GATT server.
            Writes are sent to queue with {a href="#cmd_gatt_prepare_characteristic_value_write"}prepare_characteristic_value_write{/a} command. 
            Content, offset and length of queued values are validated by this procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a}
            event indicates that all data has been written successfully or that an error response has been received.
             **/

static inline struct gecko_msg_gatt_execute_characteristic_value_write_rsp_t* gecko_cmd_gatt_execute_characteristic_value_write(uint8 connection,uint8 flags)
{
    gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_execute_characteristic_value_write.flags=flags;
    gecko_cmd_msg->header=gecko_cmd_gatt_execute_characteristic_value_write_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_execute_characteristic_value_write;
}

/** This command must be used to send a characteristic confirmation to a remote GATT server after receiving an indication. 
            The {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value_event{/a} carries the att_opcode containing handle_value_indication (0x1d) which reveals 
            that an indication has been received and this must be confirmed with this command. Confirmation needs to be sent within 30 seconds, otherwise the GATT transactions 
            between the client and the server are discontinued. **/

static inline struct gecko_msg_gatt_send_characteristic_confirmation_rsp_t* gecko_cmd_gatt_send_characteristic_confirmation(uint8 connection)
{
    gecko_cmd_msg->data.cmd_gatt_send_characteristic_confirmation.connection=connection;
    gecko_cmd_msg->header=gecko_cmd_gatt_send_characteristic_confirmation_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_send_characteristic_confirmation;
}

/** This command can be used to read the descriptor value of a characteristic in a remote GATT database. A single {a href="#evt_gatt_descriptor_value"}
            gatt_descriptor_value{/a} event is generated if the descriptor value fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_descriptor_value"}gatt_descriptor_value{/a} events are generated because the firmware 
            will automatically use the "read long" GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that all 
            data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_descriptor_value_rsp_t* gecko_cmd_gatt_read_descriptor_value(uint8 connection,uint16 descriptor)
{
    gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_descriptor_value.descriptor=descriptor;
    gecko_cmd_msg->header=gecko_cmd_gatt_read_descriptor_value_id+((3)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_read_descriptor_value;
}

/** This command can be used to write the value of a characteristic descriptor in a remote GATT database. If the given value does not fit in one ATT PDU, "write long" GATT procedure is used automatically. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} 
            event indicates that all data has been written succesfully or that an error response has been received.
             **/

static inline struct gecko_msg_gatt_write_descriptor_value_rsp_t* gecko_cmd_gatt_write_descriptor_value(uint8 connection,uint16 descriptor,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_write_descriptor_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
    }

    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.descriptor=descriptor;
    gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_write_descriptor_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_write_descriptor_value_id+((4+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_write_descriptor_value;
}

/** This command can be used to find out if a service of a remote GATT database includes one or more other services. This command generates a unique gatt_service_completed event for each included service. This command generates a unique gatt_service event for every discovered service. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has successfully completed or failed with error. **/

static inline struct gecko_msg_gatt_find_included_services_rsp_t* gecko_cmd_gatt_find_included_services(uint8 connection,uint32 service)
{
    gecko_cmd_msg->data.cmd_gatt_find_included_services.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_find_included_services.service=service;
    gecko_cmd_msg->header=gecko_cmd_gatt_find_included_services_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_find_included_services;
}

/** This command can be used to read the values of multiple characteristics from a remote GATT database at once. 
            {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} events are generated as the values are returned by the remote GATT server.
            A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that either all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_multiple_characteristic_values_rsp_t* gecko_cmd_gatt_read_multiple_characteristic_values(uint8 connection,uint8 characteristic_list_len, const uint8* characteristic_list_data)
{
    if ((uint16_t)characteristic_list_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
    }

    gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.len=characteristic_list_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_read_multiple_characteristic_values.characteristic_list.data,characteristic_list_data,characteristic_list_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_read_multiple_characteristic_values_id+((2+characteristic_list_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_read_multiple_characteristic_values;
}

/** This command can be used to read a partial characteristic value with specified offset and maximum length 
            from a remote GATT database. It is equivalent to
            {a href="#cmd_gatt_read_characteristic_value"}gatt_read_characteristic_value{/a}
            if both the offset and maximum length parameters are 0.
            A single {a href="#evt_gatt_characteristic_value"}gatt_characteristic_value{/a} event is generated 
            if the value to read fits in one ATT PDU. Otherwise more than one {a href="#evt_gatt_characteristic_value"}
            gatt_characteristic_value{/a} events are generated because the firmware will automatically use the "read long" 
            GATT procedure. A received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates
            that all data has been read successfully or that an error response has been received. **/

static inline struct gecko_msg_gatt_read_characteristic_value_from_offset_rsp_t* gecko_cmd_gatt_read_characteristic_value_from_offset(uint8 connection,uint16 characteristic,uint16 offset,uint16 maxlen)
{
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_read_characteristic_value_from_offset.maxlen=maxlen;
    gecko_cmd_msg->header=gecko_cmd_gatt_read_characteristic_value_from_offset_id+((7)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_read_characteristic_value_from_offset;
}

/** {p}This command can be used to add a characteristic value to the write queue of a remote GATT server and verify if the value was correctly received by the server. Received {a href="#evt_gatt_procedure_completed"}gatt_procedure_completed{/a} event indicates that this GATT procedure has succesfully completed or failed with error. Specifically, error code 0x0194 (data_corrupted) will be returned if the value received from the GATT server's response failed to pass the reliable write verification. At most ATT_MTU - 5 amount of data can be sent once. Writes are executed or cancelled with the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.
            Whether the writes succeeded or not are indicated in the response of the {a href="#cmd_gatt_execute_characteristic_value_write"}execute_characteristic_value_write{/a} command.{/p}
             **/

static inline struct gecko_msg_gatt_prepare_characteristic_value_reliable_write_rsp_t* gecko_cmd_gatt_prepare_characteristic_value_reliable_write(uint8 connection,uint16 characteristic,uint16 offset,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 6)
    {
        gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write;
    }

    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_prepare_characteristic_value_reliable_write.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_prepare_characteristic_value_reliable_write_id+((6+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_prepare_characteristic_value_reliable_write;
}

/** This command can be used to read the value of an attribute from a local GATT database. Only (maximum BGAPI payload size - 3) amount of data can be read once. The application can continue reading with increased offset value if it receives (maximum BGAPI payload size - 3) amount of data. **/

static inline struct gecko_msg_gatt_server_read_attribute_value_rsp_t* gecko_cmd_gatt_server_read_attribute_value(uint16 attribute,uint16 offset)
{
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.attribute=attribute;
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_value.offset=offset;
    gecko_cmd_msg->header=gecko_cmd_gatt_server_read_attribute_value_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_value;
}

/** This command can be used to read the type of an attribute from a local GATT database. The type is a UUID, usually 16 or 128 bits long. **/

static inline struct gecko_msg_gatt_server_read_attribute_type_rsp_t* gecko_cmd_gatt_server_read_attribute_type(uint16 attribute)
{
    gecko_cmd_msg->data.cmd_gatt_server_read_attribute_type.attribute=attribute;
    gecko_cmd_msg->header=gecko_cmd_gatt_server_read_attribute_type_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_read_attribute_type;
}

/** This command can be used to write the value of an attribute in the local GATT database. Writing the value of a characteristic of the local GATT database 
            will not trigger notifications or indications to the remote GATT client in case such characteristic has property of indicate or notify and the client has enabled 
            notification or indication. Notifications and indications are sent to the remote GATT client using {a href="#cmd_gatt_server_send_characteristic_notification"}
            gatt_server_send_characteristic_notification{/a} command. **/

static inline struct gecko_msg_gatt_server_write_attribute_value_rsp_t* gecko_cmd_gatt_server_write_attribute_value(uint16 attribute,uint16 offset,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
    }

    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.attribute=attribute;
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.offset=offset;
    gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_write_attribute_value.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_server_write_attribute_value_id+((5+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_write_attribute_value;
}

/** This command must be used to send a response to a {a href="#evt_gatt_server_user_read_request"}user_read_request{/a} event. The response needs to be sent within 30 second, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the characteristic value is sent to the remote GATT client in the normal way. Other attr_errorcode 
            values will cause the local GATT server to send an attribute protocol error response instead of the actual data.
            At most ATT_MTU - 1 amount of data can be sent once. Client will continue reading by sending new read request with
            increased offset value if it receives ATT_MTU - 1 amount of data. **/

static inline struct gecko_msg_gatt_server_send_user_read_response_rsp_t* gecko_cmd_gatt_server_send_user_read_response(uint8 connection,uint16 characteristic,uint8 att_errorcode,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 5)
    {
        gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
    }

    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.att_errorcode=att_errorcode;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_user_read_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_server_send_user_read_response_id+((5+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_send_user_read_response;
}

/** This command must be used to send a response to a {a href="#evt_gatt_server_user_write_request"}gatt_server_user_write_request{/a} event. The response needs to be sent within 30 seconds, otherwise no more GATT 
            transactions are allowed by the remote side. If attr_errorcode is set to 0 the ATT protocol's write response is sent to indicate to the remote GATT client that 
            the write operation was processed successfully. Other values will cause the local GATT server to send an ATT protocol error response. **/

static inline struct gecko_msg_gatt_server_send_user_write_response_rsp_t* gecko_cmd_gatt_server_send_user_write_response(uint8 connection,uint16 characteristic,uint8 att_errorcode)
{
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_user_write_response.att_errorcode=att_errorcode;
    gecko_cmd_msg->header=gecko_cmd_gatt_server_send_user_write_response_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_send_user_write_response;
}

/** This command can be used to send notifications or indications to a remote GATT client. At most ATT_MTU - 3 amount of data can be sent once. Notification or indication is sent only if the client has enabled 
            them by setting the corresponding flag to the Client Characteristic Configuration descriptor. A new indication cannot be sent before a confirmation from the GATT client is first received. The confirmation is indicated 
            by {a href="#evt_gatt_server_characteristic_status"}gatt_server_characteristic_status event{/a}. **/

static inline struct gecko_msg_gatt_server_send_characteristic_notification_rsp_t* gecko_cmd_gatt_server_send_characteristic_notification(uint8 connection,uint16 characteristic,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 4)
    {
        gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
    }

    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.connection=connection;
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_send_characteristic_notification.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_server_send_characteristic_notification_id+((4+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_send_characteristic_notification;
}

/** This command can be used to find attributes of certain type from a local GATT database. Type is usually given as 16-bit or 128-bit UUID. **/

static inline struct gecko_msg_gatt_server_find_attribute_rsp_t* gecko_cmd_gatt_server_find_attribute(uint16 start,uint8 type_len, const uint8* type_data)
{
    if ((uint16_t)type_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_gatt_server_find_attribute.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
    }

    gecko_cmd_msg->data.cmd_gatt_server_find_attribute.start=start;
    gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.len=type_len;
    memcpy(gecko_cmd_msg->data.cmd_gatt_server_find_attribute.type.data,type_data,type_len);
    gecko_cmd_msg->header=gecko_cmd_gatt_server_find_attribute_id+((3+type_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_find_attribute;
}

/** 
            Deprecated. Use GATT capability feature for dynamic configuration of services and characteristics in the local GATT database. See {a href="#cmd_gatt_server_set_capabilities"}gatt_server_set_capabilities{/a} command for the details.
            {p}This command can be used to set the local GATT database. The database should not be changed while this device is connected as peripheral since it may cause GATT attributes and data synchronization problems. If the database is changed during advertising mode, advertisement packets will not be updated until the advertising is restarted.{/p} **/

static inline struct gecko_msg_gatt_server_set_database_rsp_t* gecko_cmd_gatt_server_set_database(uint32 ptr)
{
    gecko_cmd_msg->data.cmd_gatt_server_set_database.ptr=ptr;
    gecko_cmd_msg->header=gecko_cmd_gatt_server_set_database_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_set_database;
}

/** 
                This command can be used to set which capabilities should be enabled in the local GATT database. A service is visible to remote GATT clients if at least one of its capabilities has been enabled. The same applies to a characteristic and its attributes. Capability identifiers and their corresponding bit flag values can be found in the auto-generated database header file. See UG118 for how to declare capabilities in GATT database.
                {p} Changing the capabilities of a database effectively causes a database change (attributes being added or removed) from a remote GATT client point of view. If the database has a Generic Attribute service and Service Changed characteristic, the stack will monitor local database change status and manage service changed indications for a GATT client that has enabled the indication configuration of the Service Changed characteristic.{/p}
             **/

static inline struct gecko_msg_gatt_server_set_capabilities_rsp_t* gecko_cmd_gatt_server_set_capabilities(uint32 caps,uint32 reserved)
{
    gecko_cmd_msg->data.cmd_gatt_server_set_capabilities.caps=caps;
    gecko_cmd_msg->data.cmd_gatt_server_set_capabilities.reserved=reserved;
    gecko_cmd_msg->header=gecko_cmd_gatt_server_set_capabilities_id+((8)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_gatt_server_set_capabilities;
}

/** This command can be used to send data to the defined endpoint. **/

static inline struct gecko_msg_endpoint_send_rsp_t* gecko_cmd_endpoint_send(uint8 endpoint,uint8 data_len, const uint8* data_data)
{
    if ((uint16_t)data_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_endpoint_send.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_endpoint_send;
    }

    gecko_cmd_msg->data.cmd_endpoint_send.endpoint=endpoint;
    gecko_cmd_msg->data.cmd_endpoint_send.data.len=data_len;
    memcpy(gecko_cmd_msg->data.cmd_endpoint_send.data.data,data_data,data_len);
    gecko_cmd_msg->header=gecko_cmd_endpoint_send_id+((2+data_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_endpoint_send;
}

/** This command can be used to set the destination into which data from an endpoint will be routed to. **/

static inline struct gecko_msg_endpoint_set_streaming_destination_rsp_t* gecko_cmd_endpoint_set_streaming_destination(uint8 endpoint,uint8 destination_endpoint)
{
    gecko_cmd_msg->data.cmd_endpoint_set_streaming_destination.endpoint=endpoint;
    gecko_cmd_msg->data.cmd_endpoint_set_streaming_destination.destination_endpoint=destination_endpoint;
    gecko_cmd_msg->header=gecko_cmd_endpoint_set_streaming_destination_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_endpoint_set_streaming_destination;
}

/** This command can be used to close an endpoint as well as a BLE connection.{br}When used to close an endpoint, this command must always be used with an endpoint in WAIT_CLOSE status. This is to free the endpoint for future reuse in the case when the remote side closes the connection.{br}When used to close a BLE connection, the handle of the BLE connection to be closed is used as the endpoint parameter. The connection handle is reported in the event {a href="#evt_le_connection_opened"}le_connection_opened{/a}. **/

static inline struct gecko_msg_endpoint_close_rsp_t* gecko_cmd_endpoint_close(uint8 endpoint)
{
    gecko_cmd_msg->data.cmd_endpoint_close.endpoint=endpoint;
    gecko_cmd_msg->header=gecko_cmd_endpoint_close_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_endpoint_close;
}

/** This command can be used to set endpoint flags to control and/or indicate in which mode the endpoint connection is operating. **/

static inline struct gecko_msg_endpoint_set_flags_rsp_t* gecko_cmd_endpoint_set_flags(uint8 endpoint,uint32 flags)
{
    gecko_cmd_msg->data.cmd_endpoint_set_flags.endpoint=endpoint;
    gecko_cmd_msg->data.cmd_endpoint_set_flags.flags=flags;
    gecko_cmd_msg->header=gecko_cmd_endpoint_set_flags_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_endpoint_set_flags;
}

/** This command can be used to clear endpoint flags. **/

static inline struct gecko_msg_endpoint_clr_flags_rsp_t* gecko_cmd_endpoint_clr_flags(uint8 endpoint,uint32 flags)
{
    gecko_cmd_msg->data.cmd_endpoint_clr_flags.endpoint=endpoint;
    gecko_cmd_msg->data.cmd_endpoint_clr_flags.flags=flags;
    gecko_cmd_msg->header=gecko_cmd_endpoint_clr_flags_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_endpoint_clr_flags;
}

/** This command can be used to read the data performance counters (data sent counter and data received counter) of an endpoint. **/

static inline struct gecko_msg_endpoint_read_counters_rsp_t* gecko_cmd_endpoint_read_counters(uint8 endpoint)
{
    gecko_cmd_msg->data.cmd_endpoint_read_counters.endpoint=endpoint;
    gecko_cmd_msg->header=gecko_cmd_endpoint_read_counters_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_endpoint_read_counters;
}

/** This command can be used to start a software timer. Multiple concurrent timers can be running simultaneously. There are 256 unique timer ID's available,
            but in practice the amount of concurrent timers is limited by the amount of free memory. **/

static inline struct gecko_msg_hardware_set_soft_timer_rsp_t* gecko_cmd_hardware_set_soft_timer(uint32 time,uint8 handle,uint8 single_shot)
{
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.time=time;
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.handle=handle;
    gecko_cmd_msg->data.cmd_hardware_set_soft_timer.single_shot=single_shot;
    gecko_cmd_msg->header=gecko_cmd_hardware_set_soft_timer_id+((6)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_hardware_set_soft_timer;
}

/** Deprecated. Get elapsed time since last reset of RTCC **/

static inline struct gecko_msg_hardware_get_time_rsp_t* gecko_cmd_hardware_get_time()
{
    gecko_cmd_msg->header=gecko_cmd_hardware_get_time_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_hardware_get_time;
}

/** This command can be used to start a software timer with some slack. Slack parameter allows stack to optimize wake ups and save power. Timer event is triggered between time and time + slack. See also description of {a href="#cmd_hardware_set_soft_timer"}hardware_set_soft_timer{/a} command. **/

static inline struct gecko_msg_hardware_set_lazy_soft_timer_rsp_t* gecko_cmd_hardware_set_lazy_soft_timer(uint32 time,uint32 slack,uint8 handle,uint8 single_shot)
{
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.time=time;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.slack=slack;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.handle=handle;
    gecko_cmd_msg->data.cmd_hardware_set_lazy_soft_timer.single_shot=single_shot;
    gecko_cmd_msg->header=gecko_cmd_hardware_set_lazy_soft_timer_id+((10)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_hardware_set_lazy_soft_timer;
}

/** Deprecated. This command can be used to enable or disable DC/DC. **/

static inline struct gecko_msg_hardware_enable_dcdc_rsp_t* gecko_cmd_hardware_enable_dcdc(uint8 enable)
{
    gecko_cmd_msg->data.cmd_hardware_enable_dcdc.enable=enable;
    gecko_cmd_msg->header=gecko_cmd_hardware_enable_dcdc_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_hardware_enable_dcdc;
}

/** Deprecated. This command can be used to retrieve all PS keys and their current values. For each existing PS key a flash_pskey event will be generated which includes the corresponding PS key value. **/

static inline struct gecko_msg_flash_ps_dump_rsp_t* gecko_cmd_flash_ps_dump()
{
    gecko_cmd_msg->header=gecko_cmd_flash_ps_dump_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_flash_ps_dump;
}

/** Deprecated. This command can be used to erase all PS keys and their corresponding values. **/

static inline struct gecko_msg_flash_ps_erase_all_rsp_t* gecko_cmd_flash_ps_erase_all()
{
    gecko_cmd_msg->header=gecko_cmd_flash_ps_erase_all_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_flash_ps_erase_all;
}

/** Deprecated. This command can be used to store a value into the specified PS key. Allowed PS keys are in range from 0x4000 to 0x407F. At most 56 bytes user data can be stored in one PS key. Error code 0x018a (command_too_long) will be returned if more than 56 bytes data is passed in. **/

static inline struct gecko_msg_flash_ps_save_rsp_t* gecko_cmd_flash_ps_save(uint16 key,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 3)
    {
        gecko_rsp_msg->data.rsp_flash_ps_save.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_flash_ps_save;
    }

    gecko_cmd_msg->data.cmd_flash_ps_save.key=key;
    gecko_cmd_msg->data.cmd_flash_ps_save.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_flash_ps_save.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_flash_ps_save_id+((3+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_flash_ps_save;
}

/** Deprecated. This command can be used for retrieving the value of the specified PS key. **/

static inline struct gecko_msg_flash_ps_load_rsp_t* gecko_cmd_flash_ps_load(uint16 key)
{
    gecko_cmd_msg->data.cmd_flash_ps_load.key=key;
    gecko_cmd_msg->header=gecko_cmd_flash_ps_load_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_flash_ps_load;
}

/** Deprecated. This command can be used to erase a single PS key and its value from the persistent store.. **/

static inline struct gecko_msg_flash_ps_erase_rsp_t* gecko_cmd_flash_ps_erase(uint16 key)
{
    gecko_cmd_msg->data.cmd_flash_ps_erase.key=key;
    gecko_cmd_msg->header=gecko_cmd_flash_ps_erase_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_flash_ps_erase;
}

/** 
                This command can be used to start a transmitter test. The test is meant to be used against a separate Bluetooth tester device. When the command is processed by the radio, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered. This event indicates if the test started successfully.

                {p}In the transmitter test, the device sends packets continuously with a fixed interval. The type and length of each packet is set by {b}packet_type{/b} and {b}length{/b} parameters. Parameter {b}phy{/b} specifies which PHY is used to transmit the packets. All devices support at least the 1M PHY. There is also a special packet type, {b}test_pkt_carrier{/b}, which can be used to transmit continuous unmodulated carrier. The {b}length{/b} field is ignored in this mode.{/p}

                {p}The test may be stopped using the {a href="#cmd_test_dtm_end"}test_dtm_end{/a} command.{/p}
             **/

static inline struct gecko_msg_test_dtm_tx_rsp_t* gecko_cmd_test_dtm_tx(uint8 packet_type,uint8 length,uint8 channel,uint8 phy)
{
    gecko_cmd_msg->data.cmd_test_dtm_tx.packet_type=packet_type;
    gecko_cmd_msg->data.cmd_test_dtm_tx.length=length;
    gecko_cmd_msg->data.cmd_test_dtm_tx.channel=channel;
    gecko_cmd_msg->data.cmd_test_dtm_tx.phy=phy;
    gecko_cmd_msg->header=gecko_cmd_test_dtm_tx_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_test_dtm_tx;
}

/** 
                This command can be used to start a receiver test. The test is meant to be used against a separate Bluetooth tester device. When the command is processed by the radio, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered. This event indicates if the test started successfully.

                {p}Parameter {b}phy{/b} specifies which PHY is used to receive the packets. All devices support at least the 1M PHY.{/p}

                {p}The test may be stopped using the {a href="#cmd_test_dtm_end"}test_dtm_end{/a} command. This will trigger another {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event, which carries the number of packets received during the test.{/p}
             **/

static inline struct gecko_msg_test_dtm_rx_rsp_t* gecko_cmd_test_dtm_rx(uint8 channel,uint8 phy)
{
    gecko_cmd_msg->data.cmd_test_dtm_rx.channel=channel;
    gecko_cmd_msg->data.cmd_test_dtm_rx.phy=phy;
    gecko_cmd_msg->header=gecko_cmd_test_dtm_rx_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_test_dtm_rx;
}

/** 
                This command can be used to end a transmitter or a receiver test. When the command is processed by the radio and the test has ended, a {a href="#evt_test_dtm_completed"}test_dtm_completed{/a} event is triggered.
             **/

static inline struct gecko_msg_test_dtm_end_rsp_t* gecko_cmd_test_dtm_end()
{
    gecko_cmd_msg->header=gecko_cmd_test_dtm_end_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_test_dtm_end;
}

/** debug_command **/

static inline struct gecko_msg_test_debug_command_rsp_t* gecko_cmd_test_debug_command(uint8 id,uint8 debugdata_len, const uint8* debugdata_data)
{
    if ((uint16_t)debugdata_len > 256 - 2)
    {
        gecko_rsp_msg->data.rsp_test_debug_command.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_test_debug_command;
    }

    gecko_cmd_msg->data.cmd_test_debug_command.id=id;
    gecko_cmd_msg->data.cmd_test_debug_command.debugdata.len=debugdata_len;
    memcpy(gecko_cmd_msg->data.cmd_test_debug_command.debugdata.data,debugdata_data,debugdata_len);
    gecko_cmd_msg->header=gecko_cmd_test_debug_command_id+((2+debugdata_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_test_debug_command;
}

/** debug_counter **/

static inline struct gecko_msg_test_debug_counter_rsp_t* gecko_cmd_test_debug_counter(uint32 id)
{
    gecko_cmd_msg->data.cmd_test_debug_counter.id=id;
    gecko_cmd_msg->header=gecko_cmd_test_debug_counter_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_test_debug_counter;
}

/** This command can be used to set whether the device accepts new bondings or not. **/

static inline struct gecko_msg_sm_set_bondable_mode_rsp_t* gecko_cmd_sm_set_bondable_mode(uint8 bondable)
{
    gecko_cmd_msg->data.cmd_sm_set_bondable_mode.bondable=bondable;
    gecko_cmd_msg->header=gecko_cmd_sm_set_bondable_mode_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_set_bondable_mode;
}

/** This command can be used to configure security requirements and I/O capabilities of the system. **/

static inline struct gecko_msg_sm_configure_rsp_t* gecko_cmd_sm_configure(uint8 flags,uint8 io_capabilities)
{
    gecko_cmd_msg->data.cmd_sm_configure.flags=flags;
    gecko_cmd_msg->data.cmd_sm_configure.io_capabilities=io_capabilities;
    gecko_cmd_msg->header=gecko_cmd_sm_configure_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_configure;
}

/** This command can be used to set maximum allowed bonding count and bonding policy. The default value is maximum number of bondings supported. **/

static inline struct gecko_msg_sm_store_bonding_configuration_rsp_t* gecko_cmd_sm_store_bonding_configuration(uint8 max_bonding_count,uint8 policy_flags)
{
    gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.max_bonding_count=max_bonding_count;
    gecko_cmd_msg->data.cmd_sm_store_bonding_configuration.policy_flags=policy_flags;
    gecko_cmd_msg->header=gecko_cmd_sm_store_bonding_configuration_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_store_bonding_configuration;
}

/** This command can be used to enhance the security of a connection to current security requirements. On an unencrypted connection, this will encrypt the connection and will also perform bonding if requested by both devices. On an encrypted connection, this will cause the connection re-encrypted. **/

static inline struct gecko_msg_sm_increase_security_rsp_t* gecko_cmd_sm_increase_security(uint8 connection)
{
    gecko_cmd_msg->data.cmd_sm_increase_security.connection=connection;
    gecko_cmd_msg->header=gecko_cmd_sm_increase_security_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_increase_security;
}

/** This command can be used to delete specified bonding information from Persistent Store. **/

static inline struct gecko_msg_sm_delete_bonding_rsp_t* gecko_cmd_sm_delete_bonding(uint8 bonding)
{
    gecko_cmd_msg->data.cmd_sm_delete_bonding.bonding=bonding;
    gecko_cmd_msg->header=gecko_cmd_sm_delete_bonding_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_delete_bonding;
}

/** This command can be used to delete all bonding information from Persistent Store. **/

static inline struct gecko_msg_sm_delete_bondings_rsp_t* gecko_cmd_sm_delete_bondings()
{
    gecko_cmd_msg->header=gecko_cmd_sm_delete_bondings_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_delete_bondings;
}

/** This command can be used to enter a passkey after receiving a passkey request event. **/

static inline struct gecko_msg_sm_enter_passkey_rsp_t* gecko_cmd_sm_enter_passkey(uint8 connection,int32 passkey)
{
    gecko_cmd_msg->data.cmd_sm_enter_passkey.connection=connection;
    gecko_cmd_msg->data.cmd_sm_enter_passkey.passkey=passkey;
    gecko_cmd_msg->header=gecko_cmd_sm_enter_passkey_id+((5)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_enter_passkey;
}

/** This command can be used for accepting or rejecting reported confirm value. **/

static inline struct gecko_msg_sm_passkey_confirm_rsp_t* gecko_cmd_sm_passkey_confirm(uint8 connection,uint8 confirm)
{
    gecko_cmd_msg->data.cmd_sm_passkey_confirm.connection=connection;
    gecko_cmd_msg->data.cmd_sm_passkey_confirm.confirm=confirm;
    gecko_cmd_msg->header=gecko_cmd_sm_passkey_confirm_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_passkey_confirm;
}

/** 
                This command can be used to set the OOB data (out-of-band encryption data) for legacy pairing for a device. The OOB data may be, for example, a PIN code exchanged over 
                an alternate path like NFC. The device will not allow any other kind of bonding if OOB data is set. The OOB data cannot be set simultaneously with secure connections OOB data. 
             **/

static inline struct gecko_msg_sm_set_oob_data_rsp_t* gecko_cmd_sm_set_oob_data(uint8 oob_data_len, const uint8* oob_data_data)
{
    if ((uint16_t)oob_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_sm_set_oob_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
    }

    gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.len=oob_data_len;
    memcpy(gecko_cmd_msg->data.cmd_sm_set_oob_data.oob_data.data,oob_data_data,oob_data_len);
    gecko_cmd_msg->header=gecko_cmd_sm_set_oob_data_id+((1+oob_data_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_set_oob_data;
}

/** This command can be used to list all bondings stored in the bonding database. Bondings are reported by using the {a href="#evt_sm_list_bonding_entry"}
            sm_list_bonding_entry{/a} event for each bonding and the report is ended with {a href="#evt_sm_list_all_bondings_complete"}sm_list_all_bondings_complete{/a} event. 
            Recommended to be used only for debugging purposes, because reading from the Persistent Store is relatively slow. **/

static inline struct gecko_msg_sm_list_all_bondings_rsp_t* gecko_cmd_sm_list_all_bondings()
{
    gecko_cmd_msg->header=gecko_cmd_sm_list_all_bondings_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_list_all_bondings;
}

/** This command can be used for accepting or rejecting bonding request. **/

static inline struct gecko_msg_sm_bonding_confirm_rsp_t* gecko_cmd_sm_bonding_confirm(uint8 connection,uint8 confirm)
{
    gecko_cmd_msg->data.cmd_sm_bonding_confirm.connection=connection;
    gecko_cmd_msg->data.cmd_sm_bonding_confirm.confirm=confirm;
    gecko_cmd_msg->header=gecko_cmd_sm_bonding_confirm_id+((2)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_bonding_confirm;
}

/** This command can be used to set Security Manager in debug mode. In this mode the secure connections bonding uses debug keys, so that the encrypted packet can be opened by Bluetooth protocol analyzer. To disable the debug mode, you need to restart the device. **/

static inline struct gecko_msg_sm_set_debug_mode_rsp_t* gecko_cmd_sm_set_debug_mode()
{
    gecko_cmd_msg->header=gecko_cmd_sm_set_debug_mode_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_set_debug_mode;
}

/** This command can be used to enter a fixed passkey which will be used in the {a href="#evt_sm_passkey_display"}sm_passkey_display{/a} event. **/

static inline struct gecko_msg_sm_set_passkey_rsp_t* gecko_cmd_sm_set_passkey(int32 passkey)
{
    gecko_cmd_msg->data.cmd_sm_set_passkey.passkey=passkey;
    gecko_cmd_msg->header=gecko_cmd_sm_set_passkey_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_set_passkey;
}

/** 
                This command can be used to enable the use of OOB data (out-of-band encryption data) for a device for secure connections pairing.
                The enabling will genarate new OOB data and confirm values which can be sent to the remote device.
                After enabling the secure connections OOB data, the remote devices OOB data can be set with {a href="#cmd_sm_set_sc_remote_oob_data"}sm_set_sc_remote_oob_data{/a}.
                Calling this function will erase any set remote device OOB data and confirm values.
                The device will not allow any other kind of bonding if OOB data is set. The secure connections OOB data cannot be enabled simultaneously with legacy pairing OOB data.
             **/

static inline struct gecko_msg_sm_use_sc_oob_rsp_t* gecko_cmd_sm_use_sc_oob(uint8 enable)
{
    gecko_cmd_msg->data.cmd_sm_use_sc_oob.enable=enable;
    gecko_cmd_msg->header=gecko_cmd_sm_use_sc_oob_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_use_sc_oob;
}

/** 
                This command can be used to set OOB data and confirm values (out-of-band encryption) received from the remote device for secure connections pairing.
                OOB data must be enabled with {a href="#cmd_sm_use_sc_oob"}sm_use_sc_oob{/a} before setting the remote device OOB data.
             **/

static inline struct gecko_msg_sm_set_sc_remote_oob_data_rsp_t* gecko_cmd_sm_set_sc_remote_oob_data(uint8 oob_data_len, const uint8* oob_data_data)
{
    if ((uint16_t)oob_data_len > 256 - 1)
    {
        gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data;
    }

    gecko_cmd_msg->data.cmd_sm_set_sc_remote_oob_data.oob_data.len=oob_data_len;
    memcpy(gecko_cmd_msg->data.cmd_sm_set_sc_remote_oob_data.oob_data.data,oob_data_data,oob_data_len);
    gecko_cmd_msg->header=gecko_cmd_sm_set_sc_remote_oob_data_id+((1+oob_data_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_sm_set_sc_remote_oob_data;
}

/** This command can be used to configure the Apple HomeKit accessory and its settings. It is possible to reinitialize configuration in run time. New fast advertising parameters will be used for next fast advertising. **/

static inline struct gecko_msg_homekit_configure_rsp_t* gecko_cmd_homekit_configure(uint8 i2c_address,uint8 support_display,uint8 hap_attribute_features,uint16 category,uint8 configuration_number,uint16 fast_advert_interval,uint16 fast_advert_timeout,uint32 flag)
{
    gecko_cmd_msg->data.cmd_homekit_configure.i2c_address=i2c_address;
    gecko_cmd_msg->data.cmd_homekit_configure.support_display=support_display;
    gecko_cmd_msg->data.cmd_homekit_configure.hap_attribute_features=hap_attribute_features;
    gecko_cmd_msg->data.cmd_homekit_configure.category=category;
    gecko_cmd_msg->data.cmd_homekit_configure.configuration_number=configuration_number;
    gecko_cmd_msg->data.cmd_homekit_configure.fast_advert_interval=fast_advert_interval;
    gecko_cmd_msg->data.cmd_homekit_configure.fast_advert_timeout=fast_advert_timeout;
    gecko_cmd_msg->data.cmd_homekit_configure.flag=flag;
    gecko_cmd_msg->header=gecko_cmd_homekit_configure_id+((14)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_configure;
}

/** This command can be used to start or stop Apple HomeKit accessory advertising. The command and parameters will take effect immediately. If the given parameters can't be used in the currently active mode, an error will be returned. **/

static inline struct gecko_msg_homekit_advertise_rsp_t* gecko_cmd_homekit_advertise(uint8 enable,uint16 interval_min,uint16 interval_max,uint8 channel_map)
{
    gecko_cmd_msg->data.cmd_homekit_advertise.enable=enable;
    gecko_cmd_msg->data.cmd_homekit_advertise.interval_min=interval_min;
    gecko_cmd_msg->data.cmd_homekit_advertise.interval_max=interval_max;
    gecko_cmd_msg->data.cmd_homekit_advertise.channel_map=channel_map;
    gecko_cmd_msg->header=gecko_cmd_homekit_advertise_id+((6)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_advertise;
}

/** This command can be used to delete all Apple HomeKit pairing data. **/

static inline struct gecko_msg_homekit_delete_pairings_rsp_t* gecko_cmd_homekit_delete_pairings()
{
    gecko_cmd_msg->header=gecko_cmd_homekit_delete_pairings_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_delete_pairings;
}

/** This command can be used to make an I2C test connection with Apple authentication co-processor and return error if communication failed. **/

static inline struct gecko_msg_homekit_check_authcp_rsp_t* gecko_cmd_homekit_check_authcp()
{
    gecko_cmd_msg->header=gecko_cmd_homekit_check_authcp_id+((0)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_check_authcp;
}

/** This command can be used to get pairing ID of the connected iOS device. **/

static inline struct gecko_msg_homekit_get_pairing_id_rsp_t* gecko_cmd_homekit_get_pairing_id(uint8 connection)
{
    gecko_cmd_msg->data.cmd_homekit_get_pairing_id.connection=connection;
    gecko_cmd_msg->header=gecko_cmd_homekit_get_pairing_id_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_get_pairing_id;
}

/** This command can be used to send a response to a {a href="#evt_homekit_write_request"}homekit_write_request{/a} event. The response needs to be sent within 30 seconds, otherwise no more GATT 
            transactions are allowed by the remote side. 
            {br}{br}If the status_code is set to 0 the HAP will send a response informing that the write operation was processed successfully and other values will cause the HAP to send a HAP error status response. **/

static inline struct gecko_msg_homekit_send_write_response_rsp_t* gecko_cmd_homekit_send_write_response(uint8 connection,uint16 characteristic,uint8 status_code)
{
    gecko_cmd_msg->data.cmd_homekit_send_write_response.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_send_write_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_send_write_response.status_code=status_code;
    gecko_cmd_msg->header=gecko_cmd_homekit_send_write_response_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_send_write_response;
}

/** This command can be used to send a response to a {a href="#evt_homekit_read_request"}homekit_read_request{/a} event. The response needs to be sent within 30 seconds, or otherwise no more GATT transactions are allowed by the remote side.
            {br}{br}If {b}status_code{/b} is set to 0, the characteristic value is sent to the remote GATT client through HomeKit library in a normal way. Other {b}status_code{/b} values will cause a HAP error status response instead of the actual data being sent.
            {br}{br}If the value data size is less than attribute_size then the Apple HomeKit library will send new {a href="#evt_homekit_read_request"}homekit_read_request{/a} event with suitable offset. The Apple HomeKit library provides automatic formatting for the frame as well encryption. **/

static inline struct gecko_msg_homekit_send_read_response_rsp_t* gecko_cmd_homekit_send_read_response(uint8 connection,uint16 characteristic,uint8 status_code,uint16 attribute_size,uint8 value_len, const uint8* value_data)
{
    if ((uint16_t)value_len > 256 - 7)
    {
        gecko_rsp_msg->data.rsp_homekit_send_read_response.result = bg_err_command_too_long;
        return &gecko_rsp_msg->data.rsp_homekit_send_read_response;
    }

    gecko_cmd_msg->data.cmd_homekit_send_read_response.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.status_code=status_code;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.attribute_size=attribute_size;
    gecko_cmd_msg->data.cmd_homekit_send_read_response.value.len=value_len;
    memcpy(gecko_cmd_msg->data.cmd_homekit_send_read_response.value.data,value_data,value_len);
    gecko_cmd_msg->header=gecko_cmd_homekit_send_read_response_id+((7+value_len)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_send_read_response;
}

/** This command can be used to make suitable action by HomeKit library for GSN (Global State Number) value. **/

static inline struct gecko_msg_homekit_gsn_action_rsp_t* gecko_cmd_homekit_gsn_action(uint8 action)
{
    gecko_cmd_msg->data.cmd_homekit_gsn_action.action=action;
    gecko_cmd_msg->header=gecko_cmd_homekit_gsn_action_id+((1)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_gsn_action;
}

/** 
                This command can be used to perform suitable actions for HomeKit notifications according to a connection state and the originator of the change. When device is in connected state and it is local change it sends empty indication to controller. When device is disconnected it starts fast advertising with parameters set in {a href="#cmd_homekit_configure"}homekit_configure{/a}, after timeout it reverts previous advertising settings. For both states it sets suitable Global State Number value. The fast advertising and updating GSN value only happens once during disconnected state. If the iOS device doesn't connect then calling homekit_event_notification a second time will have no effect.
             **/

static inline struct gecko_msg_homekit_event_notification_rsp_t* gecko_cmd_homekit_event_notification(uint8 connection,uint16 characteristic,uint8 change_originator)
{
    gecko_cmd_msg->data.cmd_homekit_event_notification.connection=connection;
    gecko_cmd_msg->data.cmd_homekit_event_notification.characteristic=characteristic;
    gecko_cmd_msg->data.cmd_homekit_event_notification.change_originator=change_originator;
    gecko_cmd_msg->header=gecko_cmd_homekit_event_notification_id+((4)<<8);
    gecko_handle_command(gecko_cmd_msg->header,&gecko_cmd_msg->data.payload);
    return &gecko_rsp_msg->data.rsp_homekit_event_notification;
}
#ifdef __cplusplus
}
#endif

#endif
