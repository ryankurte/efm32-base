// Copyright 2015 Silicon Laboratories, Inc.

#include PLATFORM_HEADER
#include CONFIGURATION_HEADER
#include "stack/include/ember.h"

#include "hal/hal.h"
#include "serial/serial.h"
#include "flex-bookkeeping.h"
#include "flex-callbacks.h"

// Our entry point is typically main(), except in simulation.
// In simulation we don't include the cortexm3-specific headers.
#if defined(EMBER_TEST)
  #define MAIN nodeMain
  #if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
    #undef EMBER_AF_API_DIAGNOSTIC_CORTEXM3
  #endif // EMBER_AF_API_DIAGNOSTIC_CORTEXM3
#else
  #define MAIN main
#endif // EMBER_TEST

// If serial functionality is enabled, we will initialize the serial ports
// during startup.  This has to happen after the HAL and gateway, if applicable,
// are initialized.
#ifdef EMBER_AF_API_SERIAL
  #include EMBER_AF_API_SERIAL
// TODO: SERIAL_INIT() should be auto-generated by AppBuilder
  #define SERIAL_INIT()                                                                                \
  do {                                                                                                 \
    emberSerialInit((uint8_t)APP_SERIAL, (SerialBaudRate)APP_BAUD_RATE, (SerialParity)PARITY_NONE, 1); \
  } while (FALSE)
#else
  #define SERIAL_INIT()
  #define emberSerialPrintfLine(...)
#endif

// If printing is enabled, we will print some diagnostic information about the
// most recent reset and also during runtime.  On some platforms, extended
// diagnostic information is available.
#if defined(EMBER_AF_API_SERIAL) && defined(EMBER_AF_PRINT_ENABLE)
  #if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
    #include EMBER_AF_API_DIAGNOSTIC_CORTEXM3
  #endif
static void printResetInformation(void);
  #define PRINT_RESET_INFORMATION printResetInformation
  #define emberAfGuaranteedPrint(...) \
  emberSerialGuaranteedPrintf(APP_SERIAL, __VA_ARGS__)
  #define emberAfGuaranteedPrintln(...)                   \
  do {                                                    \
    emberSerialGuaranteedPrintf(APP_SERIAL, __VA_ARGS__); \
    emberSerialGuaranteedPrintf(APP_SERIAL, "\r\n");      \
  } while (FALSE)
#else
  #define PRINT_RESET_INFORMATION()
  #define emberAfGuaranteedPrint(...)
  #define emberAfGuaranteedPrintln(...)
#endif

EmberTaskId emAppTask;
extern const EmberEventData emAppEvents[];

#ifdef EMBER_AF_PLUGIN_FREE_RTOS
extern void emberPluginRtosInitAndRunConnectTask(void);
#endif

void initAndRunMainLoop(void)
{
  EmberStatus status;

  emberTaskEnableIdling(true);

  emAppTask = emberTaskInit(emAppEvents);

  // Initialize the radio and the stack.  If this fails, we have to assert
  // because something is wrong.
  status = emberInit();
  emberSerialPrintfLine(APP_SERIAL, "Init: 0x%x", status);
  assert(status == EMBER_SUCCESS);

  emberAfInit();
  emberAfMainInitCallback();

  while (TRUE) {
    halResetWatchdog();

    // Let the stack or EZSP layer run periodic tasks.
    emberTick();

    // Let the application and plugins run periodic tasks.
    emberAfMainTickCallback();
    emberAfTick();

    emberRunTask(emAppTask);
  }
}

int MAIN(MAIN_FUNCTION_PARAMETERS)
{
  // Initialize the HAL and enable interrupts.
  halInit();

  INTERRUPTS_ON();

  SERIAL_INIT();

  PRINT_RESET_INFORMATION();

#ifdef EMBER_AF_PLUGIN_FREE_RTOS
  emberPluginRtosInitAndRunConnectTask();
#else
  initAndRunMainLoop();
#endif

  return 0;
}

void emberStackStatusHandler(EmberStatus status)
{
  emberAfStackStatusCallback(status);
  emberAfStackStatus(status);
}

void emberChildJoinHandler(EmberNodeType nodeType,
                           EmberNodeId nodeId)
{
  emberAfChildJoinCallback(nodeType, nodeId);
  emberAfChildJoin(nodeType, nodeId);
}

void emberIncomingMessageHandler(EmberIncomingMessage *message)
{
  emberAfIncomingMessageCallback(message);
  emberAfIncomingMessage(message);
}

void emberMessageSentHandler(EmberStatus status, EmberOutgoingMessage *message)
{
  emberAfMessageSentCallback(status, message);
  emberAfMessageSent(status, message);
}

void emberIncomingBeaconHandler(EmberPanId panId,
                                EmberNodeId nodeId,
                                uint8_t payloadLength,
                                uint8_t *payload)
{
  emberAfIncomingBeaconCallback(panId, nodeId, payloadLength, payload);
  emberAfIncomingBeacon(panId, nodeId, payloadLength, payload);
}

void emberActiveScanCompleteHandler(void)
{
  emberAfActiveScanCompleteCallback();
  emberAfActiveScanComplete();
}

void emberEnergyScanCompleteHandler(int8_t mean,
                                    int8_t min,
                                    int8_t max,
                                    uint16_t variance)
{
  emberAfEnergyScanCompleteCallback(mean, min, max, variance);
  emberAfEnergyScanComplete(mean, min, max, variance);
}

void emberStackIsrHandler(void)
{
  // TODO: for now we do not expose this to the application.

  emberAfStackIsr();
}

#ifdef EMBER_AF_PRINT_ENABLE

static void printResetInformation(void)
{
  // Information about the most recent reset is printed during startup to aid
  // in debugging.
  emberAfGuaranteedPrintln("Reset info: 0x%x (%p)",
                           halGetResetInfo(),
                           halGetResetString());

#if defined(EMBER_AF_API_DIAGNOSTIC_CORTEXM3)
  emberAfGuaranteedPrintln("Extended reset info: 0x%2x (%p)",
                           halGetExtendedResetInfo(),
                           halGetExtendedResetString());
  if (halResetWasCrash()) {
    halPrintCrashSummary(APP_SERIAL);
    halPrintCrashDetails(APP_SERIAL);
    halPrintCrashData(APP_SERIAL);
  }
#endif // EMBER_AF_API_DIAGNOSTIC_CORTEXM3
}

#endif // EMBER_AF_PRINT_ENABLE
